<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>H·ªá Th·ªëng Ph√¢n T√≠ch C·∫ßu (Fixed & Optimized)</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
    body {
        font-family: 'Inter', sans-serif;
        background-color: #111827; /* Tailwind gray-900 */
        color: #F9FAFB; /* Tailwind gray-50 */
    }
    .btn {
        transition: all 0.3s ease;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    .btn:active {
        transform: translateY(1px);
    }
    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .btn-export-small {
        padding: 0.25rem 0.75rem;
        font-size: 0.75rem;
        font-weight: 600;
        border-radius: 0.375rem;
        margin-left: 0.5rem;
    }
    .card-glow-p { box-shadow: 0 0 20px rgba(59, 130, 246, 0.5); }
    .card-glow-b { box-shadow: 0 0 20px rgba(239, 68, 68, 0.5); }
    .card-glow-certain { box-shadow: 0 0 25px rgba(250, 204, 21, 0.7); }
    #bigRoadDisplay {
        display: grid;
        grid-auto-flow: column;
        grid-auto-columns: 2.5rem;
        gap: 2px;
        overflow-x: auto;
        padding: 8px;
        scrollbar-width: thin;
        scrollbar-color: #4B5563 #1F2937;
    }
    .road-col {
        display: grid;
        grid-auto-rows: 2.5rem;
        gap: 2px;
    }
    .road-item {
        width: 2.5rem; height: 2.5rem; border-radius: 9999px;
        display: flex; align-items: center; justify-content: center;
        font-weight: bold; font-size: 1.125rem; color: white;
        animation: fadeIn 0.5s ease;
    }
    @keyframes fadeIn {
        from { opacity: 0; transform: scale(0.8); }
        to { opacity: 1; transform: scale(1); }
    }
    .modal-backdrop {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(0,0,0,0.7);
        display: flex; align-items: center; justify-content: center;
        z-index: 50; animation: fadeIn 0.3s ease;
    }
    .modal-content {
        background-color: #1f2937;
        padding: 1.5rem; border-radius: 1rem;
        width: 90%; max-width: 400px;
        animation: slideIn 0.3s ease-out;
        border: 1px solid #374151;
    }
    .toast-notification {
        position: fixed; top: 20px; right: 20px;
        background-color: #1f2937; color: white;
        padding: 1rem 1.5rem; border-radius: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3);
        z-index: 100; animation: slideDown 0.5s ease;
        border-left: 4px solid;
    }
    @keyframes slideIn {
        from { opacity: 0; transform: translateY(-20px) scale(0.95); }
        to { opacity: 1; transform: translateY(0) scale(1); }
    }
    @keyframes slideDown {
        from { opacity: 0; transform: translateY(-100%); }
        to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeOut {
        from { opacity: 1; transform: translateY(0); }
        to { opacity: 0; transform: translateY(-20px); }
    }
    #sessionManagementContent {
        transition: max-height 0.5s ease-in-out;
        overflow: hidden;
    }
    .history-chart {
        display: flex;
        align-items: flex-end;
        justify-content: center;
        gap: 1px;
        height: 40px;
        padding: 5px 0;
        overflow: hidden;
    }
    .history-bar {
        flex-shrink: 0;
        width: 3px;
        border-radius: 1px;
    }
    .history-bar-correct {
        background-color: #3b82f6;
        height: 100%;
    }
    .history-bar-incorrect {
        background-color: #ef4444;
        height: 40%;
    }
</style>
</head>
<body class="p-4 md:p-8">
    <div id="modal-container"></div>
    <div id="toast-container"></div>
    <div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-6">
        <!-- Left Column: Input & History -->
        <div class="lg:col-span-2 space-y-6">
            <!-- Header -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg text-center">
                <h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-red-400">H·ªá Th·ªëng Ph√¢n T√≠ch C·∫ßu</h1>
                <p class="text-gray-400 mt-2">Ghi nh·ªõ - ƒê·ªëi chi·∫øu - Ph√°n ƒëo√°n (Phi√™n b·∫£n V1.2 Fixed)</p>
            </div>
            <!-- Session Management -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <div class="flex justify-between items-center cursor-pointer" onclick="toggleSessionManagement()">
                    <h2 class="text-xl font-semibold text-blue-300">üìÅ Qu·∫£n L√Ω Phi√™n</h2>
                    <button id="toggleSessionBtn" class="text-gray-400 hover:text-white p-1">
                        <svg id="toggleSessionIcon" class="w-6 h-6 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                <div id="sessionManagementContent">
                    <div class="mt-4">
                        <div class="flex flex-col sm:flex-row gap-4 mb-2">
                            <select id="sessionSelector" multiple size="5" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"></select>
                            <div class="grid grid-cols-2 gap-4">
                                <button onclick="createNewSession()" class="btn w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg">‚ûï M·ªõi</button>
                                <button onclick="renameSession()" class="btn w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg">‚úèÔ∏è ƒê·ªïi T√™n</button>
                                <button onclick="deleteSelectedSessions()" class="btn w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg col-span-2">üóëÔ∏è X√≥a M·ª•c ƒê√£ Ch·ªçn</button>
                                <button onclick="deleteAllSessions()" class="btn w-full bg-red-800 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg col-span-2">üí• X√≥a T·∫•t C·∫£</button>
                            </div>
                        </div>
                        <p class="text-xs text-gray-500 text-center mb-4 sm:text-left">M·∫πo: Gi·ªØ ph√≠m Shift ho·∫∑c Ctrl (Cmd tr√™n Mac) ƒë·ªÉ ch·ªçn nhi·ªÅu phi√™n.</p>
                        <div class="flex flex-col sm:flex-row gap-4">
                            <button onclick="exportData()" class="btn w-full bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-4 rounded-lg">üì§ Xu·∫•t T·ªïng Th·ªÉ</button>
                            <button onclick="document.getElementById('fileInput').click()" class="btn w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">üì• Nh·∫≠p D·ªØ Li·ªáu</button>
                            <input type="file" id="fileInput" class="hidden" accept=".json" onchange="importData(event)">
                        </div>
                    </div>
                </div>
            </div>

            <!-- CH·ªêT ANALYSIS PANEL -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 text-purple-300">üîê Ch·ªët Ph√°n Quy·∫øt</h2>
                <div id="finalChotResult" class="text-center bg-gray-900 py-4 rounded-lg border-2 border-purple-500 mb-4 transition-all duration-300">
                    <p class="text-sm text-gray-400 mb-1">ƒê·ªÅ xu·∫•t "CH·ªêT" (Optimal/Max/Fallback):</p>
                    <p id="finalChotResultText" class="text-2xl font-extrabold text-gray-400">... Ch·ªù t√≠n hi·ªáu ...</p>
                </div>
                <div id="chotAnalysisDetails" class="space-y-1">
                    <p class="text-gray-500 text-center py-4">ƒêang t·∫£i d·ªØ li·ªáu ph√¢n t√≠ch Ch·ªët...</p>
                </div>
                <div id="chotHistoryChartContainer" class="bg-gray-900 rounded-lg p-3 mt-4">
                    <div class="flex justify-between items-center mb-2 px-1">
                        <span class="text-xs font-medium text-gray-400">L·ªãch s·ª≠ ƒê√∫ng/Sai c·ªßa Ch·ªët (T·ªëi ƒëa 50 v√°n g·∫ßn nh·∫•t):</span>
                        <span id="chotAccuracyStats" class="text-xs font-semibold text-gray-300">ƒê√∫ng: 0/0 (0.0%)</span>
                    </div>
                    <div id="chotHistoryChart" class="history-chart">
                        <p class="text-gray-600 text-xs text-center w-full">Ch∆∞a c√≥ d·ªØ li·ªáu l·ªãch s·ª≠ Ch·ªët...</p>
                    </div>
                </div>
            </div>

            <!-- Input Section -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 text-blue-300">üé≤ Nh·∫≠p K·∫øt Qu·∫£ V√°n Hi·ªán T·∫°i</h2>
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <button onclick="handleAddResultClick('P')" class="btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-6 rounded-lg text-2xl"><span>üë§</span> PLAYER</button>
                    <button onclick="handleAddResultClick('B')" class="btn bg-red-600 hover:bg-red-500 text-white font-bold py-6 rounded-lg text-2xl"><span>üè¶</span> BANKER</button>
                </div>
                <div class="flex gap-4">
                    <button onclick="undoLast()" class="btn flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg">‚Ü©Ô∏è Ho√†n T√°c</button>
                    <button onclick="showCustomConfirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ v√† th·ªëng k√™ c·ªßa phi√™n n√†y kh√¥ng?', clearCurrentSessionHistory)" class="btn flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg">üóëÔ∏è X√≥a L·ªãch S·ª≠</button>
                </div>
            </div>

            <!-- History Display (Big Road) -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold text-blue-300">üìú B·∫£ng C·∫ßu Big Road</h2>
                    <span class="text-gray-400 font-medium">T·ªïng: <span id="totalGames">0</span> v√°n</span>
                </div>
                <div class="bg-gray-900 rounded-lg min-h-[280px] border border-gray-700">
                    <div id="bigRoadDisplay">
                        <p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>
                    </div>
                </div>
            </div>

            <!-- Verdict & Confidence Stats -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-xl font-semibold text-indigo-300">‚öñÔ∏è Th·ªëng K√™ Ph√°n Quy·∫øt</h2>
                    <button onclick="exportVerdictStats()" class="btn btn-export-small bg-indigo-600 hover:bg-indigo-500 text-white">üì§ Xu·∫•t</button>
                </div>
                <div class="mt-4 space-y-2" id="verdictStatsTable"></div>
            </div>
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-xl font-semibold text-green-300">üìä Th·ªëng K√™ ƒê·ªô Tin C·∫≠y</h2>
                    <button onclick="exportConfidenceStats()" class="btn btn-export-small bg-green-600 hover:bg-green-500 text-white">üì§ Xu·∫•t</button>
                </div>
                <div id="confidenceRecommendation" class="my-4 p-3 bg-gray-900 rounded-lg text-center"></div>
                <div class="space-y-2" id="confidenceStatsTable"></div>
            </div>
        </div>

        <!-- Right Column: Analysis & Stats -->
        <div class="space-y-6">
            <!-- Accuracy Stats -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 text-green-300">üéØ Th·ªëng K√™ (Phi√™n Hi·ªán T·∫°i)</h2>
                <div class="space-y-4">
                    <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                        <span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>
                        <span id="accuracyRate" class="text-2xl font-bold text-green-400">0.0%</span>
                    </div>
                    <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                        <span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>
                        <div><span id="correctPredictions" class="text-lg font-semibold text-white">0</span><span class="text-gray-400">/</span><span id="totalPredictions" class="text-lg font-semibold text-white">0</span></div>
                    </div>
                </div>
            </div>
            <!-- Global Accuracy Stats -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 text-cyan-300">üåê Th·ªëng K√™ (To√†n C·ª•c)</h2>
                <div class="space-y-4">
                    <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                        <span class="font-medium text-gray-300">T·ª∑ L·ªá Th·∫Øng</span>
                        <span id="globalAccuracyRate" class="text-2xl font-bold text-cyan-400">0.0%</span>
                    </div>
                    <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                        <span class="font-medium text-gray-300">Th·∫Øng / T·ªïng Ph√°n ƒêo√°n</span>
                        <div><span id="globalCorrectPredictions" class="text-lg font-semibold text-white">0</span><span class="text-gray-400">/</span><span id="globalTotalPredictions" class="text-lg font-semibold text-white">0</span></div>
                    </div>
                </div>
            </div>
            <!-- Pattern Analysis -->
            <div id="analysis-card" class="bg-gray-800 p-6 rounded-2xl shadow-lg transition-shadow duration-500">
                <h2 class="text-xl font-semibold mb-4 text-yellow-300">üß† Ph√°n Quy·∫øt (Ph√¢n T√≠ch T·ªïng H·ª£p)</h2>
                <div id="analysisResult" class="space-y-4">
                    <p class="text-gray-400 text-center py-8">C·∫ßn √≠t nh·∫•t 10 k·∫øt qu·∫£ ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√¢n t√≠ch...</p>
                </div>
            </div>
        </div>
    </div>

<script>
// --- GLOBAL CONSTANTS ---
const CHOT_SOURCES = ['follow', 'against', '90-100', '80-90', '70-80', '60-70', '50-60'];
const CONFIDENCE_RANGES = [
    { key: '50-60', min: 50, max: 60 }, { key: '60-70', min: 60, max: 70 },
    { key: '70-80', min: 70, max: 80 }, { key: '80-90', min: 80, max: 90 },
    { key: '90-100', min: 90, max: 100.1 }
];

// --- CORE LOGIC: PATTERN MATCHER ---
class PatternMatcher {
    constructor() {
        this.MIN_HISTORY_FOR_ANALYSIS = 10;
        this.MIN_PATTERN_LENGTH = 10;
        this.MAX_PATTERN_LENGTH = 20;
        this.MIN_CERTAIN_OCCURRENCES = 5;
    }
    calculateSimilarity(arr1, arr2) {
        if (arr1.length !== arr2.length || arr1.length === 0) return 0;
        const matches = arr1.filter((item, index) => item === arr2[index]).length;
        return matches / arr1.length;
    }
    findPatternOccurrences(pattern, allHistory) {
        const occurrences = [];
        const reversedPattern = [...pattern].reverse();
        for (const session of allHistory) {
            const sessionHistory = session.history || [];
            if (sessionHistory.length < pattern.length + 1) continue;
            for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {
                const segment = sessionHistory.slice(i, i + pattern.length);
                const nextResult = sessionHistory[i + pattern.length];
                const similarity = this.calculateSimilarity(pattern, segment);
                if (similarity >= 0.9) occurrences.push({ type: 'similar', next: nextResult, similarity });
                const reverseSimilarity = this.calculateSimilarity(reversedPattern, segment);
                if (reverseSimilarity >= 0.9) occurrences.push({ type: 'reversed', next: nextResult, similarity: reverseSimilarity });
            }
        }
        return occurrences;
    }
    getPredictionForPattern(pattern, allHistoricalSessions) {
        const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);
        if (occurrences.length === 0) return { prediction: null };
        const votes = { P: 0, B: 0 };
        occurrences.forEach(match => { if (votes[match.next] !== undefined) votes[match.next] += match.similarity; });
        const totalVotes = votes.P + votes.B;
        if (totalVotes === 0) return { prediction: null };
        const predictedWinner = votes.P > votes.B ? 'P' : 'B';
        const confidence = (Math.max(votes.P, votes.B) / totalVotes) * 100;
        return { prediction: predictedWinner, confidence, votes, totalOccurrences: occurrences.length };
    }
    findCertainPrediction(currentHistory, allHistoricalSessions) {
        for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {
            const pattern = currentHistory.slice(-len);
            const patternString = pattern.join('');
            const occurrences = [];
            for (const session of allHistoricalSessions) {
                const sessionHistory = session.history || [];
                if (sessionHistory.length < pattern.length + 1) continue;
                for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {
                    const segment = sessionHistory.slice(i, i + pattern.length);
                    if (segment.join('') === patternString) {
                        occurrences.push(sessionHistory[i + pattern.length]);
                    }
                }
            }
            if (occurrences.length >= this.MIN_CERTAIN_OCCURRENCES && new Set(occurrences).size === 1) {
                return {
                    prediction: occurrences[0],
                    recommendation: 'TAY CH·∫ÆC CH·∫ÆN',
                    analysisText: `T√¨m th·∫•y ${occurrences.length} l·∫ßn xu·∫•t hi·ªán ch√≠nh x√°c c·ªßa h√¨nh c·∫ßu n√†y trong l·ªãch s·ª≠.\nT·∫•t c·∫£ ƒë·ªÅu cho k·∫øt qu·∫£ ti·∫øp theo l√†: ${occurrences[0]}`,
                    confidence: 100,
                    isCertain: true
                };
            }
        }
        return null;
    }
    analyzeCurrentStreak(currentHistory) {
        if (currentHistory.length < 2) return { type: 'none', length: currentHistory.length };
        const last = currentHistory[currentHistory.length - 1];
        if (last === currentHistory[currentHistory.length - 2]) {
            let length = 0;
            for (let i = currentHistory.length - 1; i >= 0; i--) {
                if (currentHistory[i] === last) length++; else break;
            }
            return { type: 'b·ªát', length, value: last };
        } else {
            let length = 0;
            for (let i = currentHistory.length - 1; i >= 1; i--) {
                if (currentHistory[i] !== currentHistory[i-1]) length++; else break;
            }
            return { type: '1-1', length: length + 1 };
        }
    }
    getPrediction(currentHistory, allHistoricalSessions, { optimalLength = null, lengthPerformance = {} } = {}) {
        if (currentHistory.length < this.MIN_HISTORY_FOR_ANALYSIS) {
            return { prediction: null, analysisText: `C·∫ßn √≠t nh·∫•t ${this.MIN_HISTORY_FOR_ANALYSIS} k·∫øt qu·∫£...`, confidence: 0, isCertain: false };
        }
        if (optimalLength && currentHistory.length >= optimalLength) {
            const pattern = currentHistory.slice(-optimalLength);
            const result = this.getPredictionForPattern(pattern, allHistoricalSessions);
            if (result.prediction) {
                const perf = lengthPerformance[optimalLength] || { wins: 0, total: 0 };
                const rate = perf.total > 0 ? (perf.wins / perf.total * 100).toFixed(1) : 'N/A';
                return {
                    prediction: result.prediction, recommendation: 'THEO CHI·ªÄU D√ÄI T·ªêI ∆ØU',
                    analysisText: `S·ª≠ d·ª•ng chi·ªÅu d√†i c·∫ßu t·ªëi ∆∞u: ${optimalLength} v√°n.\n(T·ª∑ l·ªá th·∫Øng: ${rate}%)\n\nL·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${result.votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${result.votes.B.toFixed(1)} ƒëi·ªÉm`,
                    confidence: result.confidence, isCertain: false
                };
            }
        }
        const certainPrediction = this.findCertainPrediction(currentHistory, allHistoricalSessions);
        if (certainPrediction) return certainPrediction;
        const allMatches = [];
        for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {
            const pattern = currentHistory.slice(-len);
            const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);
            if (occurrences.length > 0) {
                allMatches.push(...occurrences);
                break;
            }
        }
        if (allMatches.length === 0) return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª±.', confidence: 0, isCertain: false };
        const votes = { P: 0, B: 0 };
        allMatches.forEach(match => { if (votes[match.next] !== undefined) votes[match.next] += match.similarity; });
        const totalVotes = votes.P + votes.B;
        if (totalVotes === 0) return { prediction: null, analysisText: 'Kh√¥ng t√¨m th·∫•y h√¨nh c·∫ßu t∆∞∆°ng t·ª±.', confidence: 0, isCertain: false };
        const predictedWinner = votes.P > votes.B ? 'P' : 'B';
        const maxConfidence = (Math.max(votes.P, votes.B) / totalVotes) * 100;
        const analysisTextPrefix = `T√¨m th·∫•y ${allMatches.length} h√¨nh c·∫ßu t∆∞∆°ng t·ª±. L·ªãch s·ª≠ cho th·∫•y:\n- PLAYER: ${votes.P.toFixed(1)} ƒëi·ªÉm\n- BANKER: ${votes.B.toFixed(1)} ƒëi·ªÉm`;
        const streakInfo = this.analyzeCurrentStreak(currentHistory);
        let recommendation = 'THEO PH√ÇN T√çCH L·ªäCH S·ª¨';
        if (streakInfo.type === 'b·ªát') recommendation = predictedWinner === streakInfo.value ? `THEO B·ªÜT (${streakInfo.value}x${streakInfo.length})` : `B·∫∫ C·∫¶U B·ªÜT (${streakInfo.value}x${streakInfo.length})`;
        else if (streakInfo.type === '1-1') recommendation = predictedWinner !== currentHistory[currentHistory.length - 1] ? `THEO C·∫¶U 1-1 (D√†i ${streakInfo.length})` : `B·∫∫ C·∫¶U 1-1 (D√†i ${streakInfo.length})`;
        return { prediction: predictedWinner, recommendation, analysisText: `${analysisTextPrefix}\n\nüèÜ ƒê·ªô tin c·∫≠y: ${maxConfidence.toFixed(1)}%`, confidence: maxConfidence, isCertain: false };
    }
}

// --- GLOBAL STATE ---
let state = {
    currentSessionId: null,
    sessions: {},
    matcher: new PatternMatcher(),
    currentPrediction: null,
    originalSystemPrediction: null,
    currentFinalPrediction: null,
    currentChotPredictionForLog: null,
    goldenRange: null,
    deathRange: null,
    sessionConfidenceRanges: [],
    confidenceSequenceData: {}
};

// --- STATS UTILS ---
function getPredictionStats(predictions) {
    const total = predictions.length;
    if (total === 0) return { rate: 0, correct: 0, total: 0 };
    const correct = predictions.filter(p => p.predicted === p.actual).length;
    return { rate: (correct / total) * 100, correct, total };
}
function calculateConfidenceRangeStats(predictions) {
    const ranges = CONFIDENCE_RANGES.map(r => ({ ...r, total: 0, wins: 0, rate: -1 }));
    ranges.forEach(range => {
        const predictionsForRange = predictions.filter(p => p.confidence >= range.min && (p.confidence < range.max));
        range.total = predictionsForRange.length;
        range.wins = predictionsForRange.filter(p => p.predicted === p.actual).length;
        range.rate = range.total > 0 ? ((range.wins / range.total) * 100) : -1;
    });
    return ranges;
}
function getConfidenceSequenceData() {
    const sequenceData = {};
    CONFIDENCE_RANGES.forEach(r => { sequenceData[r.key] = {}; });
    for (const sessionId in state.sessions) {
        const session = state.sessions[sessionId];
        if (!session.predictions || session.predictions.length === 0) continue;
        const sessionSequences = {};
        CONFIDENCE_RANGES.forEach(r => { sessionSequences[r.key] = []; });
        session.predictions.forEach(p => {
            const result = (p.predicted === p.actual) ? 'W' : 'L';
            const foundRange = CONFIDENCE_RANGES.find(r => p.confidence >= r.min && p.confidence < r.max);
            if (foundRange) sessionSequences[foundRange.key].push(result);
        });
        for (const key in sessionSequences) {
            if (sessionSequences[key].length > 0) sequenceData[key][sessionId] = sessionSequences[key].join('');
        }
    }
    return sequenceData;
}
function getCurrentStreak(sequence) {
    if (!sequence || sequence.length === 0) return { type: null, length: 0 };
    const lastChar = sequence.slice(-1);
    let length = 0;
    for (let i = sequence.length - 1; i >= 0; i--) {
        if (sequence[i] === lastChar) length++; else break;
    }
    return { type: lastChar, length };
}
function calculateStreakStats(sequencesObject) {
    let maxW = 0, maxL = 0;
    const allSequences = Object.values(sequencesObject).join('');
    if (!allSequences) return { maxW: 0, maxL: 0 };
    const winStreaks = allSequences.match(/W+/g) || [];
    if (winStreaks.length > 0) maxW = Math.max(...winStreaks.map(s => s.length));
    const lossStreaks = allSequences.match(/L+/g) || [];
    if (lossStreaks.length > 0) maxL = Math.max(...lossStreaks.map(s => s.length));
    return { maxW, maxL };
}

// --- VERDICT LOGIC ---
function getFinalVerdict(context) {
    const { prediction, confidence, sequenceData, currentSessionId } = context;
    if (!prediction) return { verdict: 'neutral', explanation: 'Ch∆∞a c√≥ ƒë·ªß d·ªØ li·ªáu.' };
    const foundRange = CONFIDENCE_RANGES.find(r => confidence >= r.min && confidence < r.max);
    if (!foundRange) return { verdict: 'neutral', explanation: 'Ngo√†i kho·∫£ng tin c·∫≠y.' };
    const rangeKey = foundRange.key;
    const historicalSequences = { ...sequenceData[rangeKey] };
    const currentSequenceStr = historicalSequences[currentSessionId] || "";
    delete historicalSequences[currentSessionId];

    // Tier 1: Longest Pattern
    const maxLen = Math.min(currentSequenceStr.length, 5);
    for (let len = maxLen; len >= 2; len--) {
        const patternToSearch = currentSequenceStr.slice(-len);
        let wins = 0, losses = 0;
        for (const sessionId in historicalSequences) {
            const history = historicalSequences[sessionId];
            let i = -1;
            while ((i = history.indexOf(patternToSearch, i + 1)) !== -1) {
                const nextCharIndex = i + patternToSearch.length;
                if (nextCharIndex < history.length) {
                    if (history[nextCharIndex] === 'W') wins++; else losses++;
                }
            }
        }
        if (wins + losses >= 2) {
            const patternText = patternToSearch.replace(/W/g, 'Th·∫Øng-').replace(/L/g, 'Thua-').slice(0, -1);
            if (wins > losses) return { verdict: 'follow', explanation: `N√™n theo (Quy lu·∫≠t: ${patternText} -> W).` };
            if (losses > wins) return { verdict: 'against', explanation: `N√™n ƒëi ng∆∞·ª£c (Quy lu·∫≠t: ${patternText} -> L).` };
        }
    }
    // Tier 2: Max Streak Analysis
    const currentStreak = getCurrentStreak(currentSequenceStr);
    const streakStats = calculateStreakStats(historicalSequences);
    if (currentStreak.type === 'W' && streakStats.maxW > 0 && currentStreak.length >= streakStats.maxW) {
        return { verdict: 'against', explanation: `N√™n ƒëi ng∆∞·ª£c (ƒê√£ ch·∫°m ng∆∞·ª°ng Max Th·∫Øng ${streakStats.maxW}).` };
    }
    if (currentStreak.type === 'L' && streakStats.maxL > 0 && currentStreak.length >= streakStats.maxL) {
        return { verdict: 'follow', explanation: `N√™n theo (ƒê√£ ch·∫°m ng∆∞·ª°ng Max Thua ${streakStats.maxL}).` };
    }
    // Tier 3: Absolute Pattern Fallback
    const absolutePatternLength = Math.min(currentSequenceStr.length, 3);
    if (absolutePatternLength >= 2) {
        const patternToSearch = currentSequenceStr.slice(-absolutePatternLength);
        let crossWins = 0, crossLosses = 0;
        for (const key in sequenceData) {
            const otherRangeSequences = sequenceData[key];
            for (const sessionId in otherRangeSequences) {
                if (sessionId === currentSessionId) continue;
                const history = otherRangeSequences[sessionId];
                let i = -1;
                while ((i = history.indexOf(patternToSearch, i + 1)) !== -1) {
                    const nextCharIndex = i + patternToSearch.length;
                    if (nextCharIndex < history.length) {
                        if (history[nextCharIndex] === 'W') crossWins++; else crossLosses++;
                    }
                }
            }
        }
        if (crossWins + crossLosses >= 4) {
            if (crossWins === 0) return { verdict: 'against', explanation: 'ƒêi ng∆∞·ª£c (Quy lu·∫≠t tuy·ªát ƒë·ªëi to√†n c·ª•c: Thua).' };
            if (crossLosses === 0) return { verdict: 'follow', explanation: 'N√™n theo (Quy lu·∫≠t tuy·ªát ƒë·ªëi to√†n c·ª•c: Th·∫Øng).' };
        }
    }
    return { verdict: 'neutral', explanation: 'Kh√¥ng c√≥ t√≠n hi·ªáu r√µ r√†ng.' };
}

// --- CHOT ANALYSIS LOGIC ---
function getChotAnalysisData() {
    const sequencesBySource = CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {});
    for (const sessionId in state.sessions) {
        const session = state.sessions[sessionId];
        let followSeq = '', againstSeq = '';
        (session.verdictPredictions || []).forEach(p => {
            const result = p.predicted === p.actual ? 'W' : 'L';
            if (p.verdict === 'follow') followSeq += result;
            else if (p.verdict === 'against') againstSeq += result;
        });
        sequencesBySource.follow[sessionId] = followSeq;
        sequencesBySource.against[sessionId] = againstSeq;
        CONFIDENCE_RANGES.forEach(r => {
             if (!sequencesBySource[r.key]) sequencesBySource[r.key] = {};
             sequencesBySource[r.key][sessionId] = "";
        });
        (session.predictions || []).forEach(p => {
            const result = (p.predicted === p.actual) ? 'W' : 'L';
            const foundRange = CONFIDENCE_RANGES.find(r => p.confidence >= r.min && p.confidence < r.max);
            if (foundRange) sequencesBySource[foundRange.key][sessionId] += result;
        });
    }
    return sequencesBySource;
}
function findNextOutcomeInHistory(pattern, historicalSequences) {
    if (!pattern || pattern.length < 1) return { W: 0, L: 0, total: 0 };
    let W = 0, L = 0;
    for (const sessionId in historicalSequences) {
        const history = historicalSequences[sessionId];
        if (!history || history.length < pattern.length + 1) continue;
        let i = -1;
        while ((i = history.indexOf(pattern, i + 1)) !== -1) {
            const nextCharIndex = i + pattern.length;
            const prevCharDifferent = (i === 0 || history[i - 1] !== pattern[pattern.length - 1]);
            if (prevCharDifferent && nextCharIndex < history.length) {
                if (history[nextCharIndex] === 'W') W++; else L++;
            }
        }
    }
    return { W, L, total: W + L };
}
function findBestChotPatternLength(currentSequence, historicalSequences, minLen = 3, maxLen = 20, minOccurrences = 2) {
    const possibleResults = [];
    for (let len = Math.min(maxLen, currentSequence.length); len >= minLen; len--) {
        const pattern = currentSequence.slice(-len);
        if (!pattern) continue;
        const stats = findNextOutcomeInHistory(pattern, historicalSequences);
        if (stats.total >= minOccurrences) {
            const rateW = stats.total > 0 ? stats.W / stats.total : 0;
            possibleResults.push({ length: len, stats: stats, rate: rateW });
        }
    }
    if (possibleResults.length === 0) return null;
    possibleResults.sort((a, b) => {
        const deviationA = Math.abs(a.rate - 0.5);
        const deviationB = Math.abs(b.rate - 0.5);
        if (deviationA !== deviationB) return deviationB - deviationA;
        return b.stats.total - a.stats.total;
    });
    return possibleResults[0];
}
function analyzeMaxStreak(currentSequence, historicalSequences) {
    const { type: currentType, length: currentLength } = getCurrentStreak(currentSequence);
    if (!currentType) return null;
    const { maxW, maxL } = calculateStreakStats(historicalSequences);
    
    // --- FIX 4: S·ª¨A L·ªñI LOGIC G·ªíNG L·ªñ ---
    // Ch·ªâ b√°o "B·∫ª" khi chu·ªói hi·ªán t·∫°i B·∫∞NG Max l·ªãch s·ª≠. N·∫øu v∆∞·ª£t qua (Breakout), kh√¥ng b√°o n·ªØa.
    if (currentType === 'W' && maxW > 0) {
        if (currentLength === maxW) {
             return { predictionType: 'MAX_STREAK', predictedWL: 'L', explanation: `Ch·∫°m ƒë·ªânh Max W (${maxW})`, stats: { W: 0, L: 999, total: 999 } };
        }
    }
    if (currentType === 'L' && maxL > 0) {
        if (currentLength === maxL) {
            return { predictionType: 'MAX_STREAK', predictedWL: 'W', explanation: `Ch·∫°m ƒë√°y Max L (${maxL})`, stats: { W: 999, L: 0, total: 999 } };
        }
    }
    return null;
}
function getChotPrediction(currentSequence, historicalSequences, sourceKey) {
    const session = state.sessions[state.currentSessionId];
    if (!session) return { predictionType: 'NOT_ENOUGH_WL' };
    const optimalLength = session.chotOptimalLengths ? session.chotOptimalLengths[sourceKey] : null;
    // 1. Optimal Length
    if (optimalLength && currentSequence.length >= optimalLength) {
        const pattern = currentSequence.slice(-optimalLength);
        const stats = findNextOutcomeInHistory(pattern, historicalSequences);
        if (stats.total > 0) {
            if (stats.W > stats.L) return { predictionType: 'OPTIMAL', predictedWL: 'W', stats: stats, optimalLength: optimalLength };
            if (stats.L > stats.W) return { predictionType: 'OPTIMAL', predictedWL: 'L', stats: stats, optimalLength: optimalLength };
        }
    }
    // 2. Max Streak (with fix)
    const maxStreakAnalysis = analyzeMaxStreak(currentSequence, historicalSequences);
    if (maxStreakAnalysis) return maxStreakAnalysis;
    // 3. Fallback Pattern
    const MIN_PATTERN_LEN = 3;
    if (currentSequence.length < MIN_PATTERN_LEN) return { predictionType: 'NOT_ENOUGH_WL' };
    const bestPatternInfo = findBestChotPatternLength(currentSequence, historicalSequences, MIN_PATTERN_LEN, 20, 2);
    if (!bestPatternInfo) return { predictionType: 'NO_HISTORY_PATTERN' };
    const { stats, length } = bestPatternInfo;
    if (stats.W > stats.L) return { predictionType: 'FALLBACK', predictedWL: 'W', stats: stats, optimalLength: length };
    if (stats.L > stats.W) return { predictionType: 'FALLBACK', predictedWL: 'L', stats: stats, optimalLength: length };
    return { predictionType: 'BALANCED', stats: stats, optimalLength: length };
}

// --- NEW ARCHITECTURE: SEPARATE LOGIC AND UI ---

// Function to calculate all state needed for a step WITHOUT touching DOM
function calculateSessionStateForNewResult(session, result, isImport = false) {
    // 1. Snapshot for undoing/logging needs to happen BEFORE pushing new history
    // But we need to know what the prediction WAS for this step.
    // In import, we re-calculate prediction. In live, we use state.
    
    // Recalculate HT1 state as if we were at that point in time
    const optimalLenHT1 = updateLengthPerformanceAndFindOptimal([...session.history], Object.values(state.sessions), null);
    session.optimalLength = optimalLenHT1; // Temporarily set for prediction
    
    const { prediction: predHt1, confidence: confHt1 } = state.matcher.getPrediction(session.history, Object.values(state.sessions), {
        optimalLength: session.optimalLength,
        lengthPerformance: session.lengthPerformance
    });
    
    // Recalculate Verdict state
    state.confidenceSequenceData = getConfidenceSequenceData(); // Update sequence data based on CURRENT state
    const verdictContext = {
        prediction: predHt1, confidence: confHt1,
        sequenceData: state.confidenceSequenceData,
        currentSessionId: state.currentSessionId
    };
    const finalVerdictInfo = getFinalVerdict(verdictContext);
    
    // Recalculate Chot state
    // We need to simulate the voting. This is heavy but necessary for correctness.
    const activeSourcesKeys = new Set();
    if (finalVerdictInfo.verdict === 'follow') activeSourcesKeys.add('follow');
    else if (finalVerdictInfo.verdict === 'against') activeSourcesKeys.add('against');
    const activeConfidenceRange = CONFIDENCE_RANGES.find(r => confHt1 >= r.min && confHt1 < r.max);
    if (activeConfidenceRange) activeSourcesKeys.add(activeConfidenceRange.key);
    
    const allSequences = getChotAnalysisData(); // Snapshot of W/L history
    const finalVotesPB = { P: 0, B: 0 };
    let chotLog = null;

    if (predHt1 && finalVerdictInfo) {
        CHOT_SOURCES.forEach(sourceKey => {
            const isActive = activeSourcesKeys.has(sourceKey);
            if (isActive) {
                const currentSeq = allSequences[sourceKey]?.[state.currentSessionId] || "";
                const histData = { ...allSequences[sourceKey] };
                if (histData) delete histData[state.currentSessionId];
                
                const analysisRes = getChotPrediction(currentSeq, histData, sourceKey);
                const predictedWL = analysisRes.predictedWL || null;
                let voteFor = null;

                // --- FIX 3: NaN Prevention ---
                if (predictedWL && predHt1) {
                    if (sourceKey === 'against') {
                         voteFor = (predictedWL === 'W') ? (predHt1 === 'P' ? 'B' : 'P') : predHt1;
                    } else {
                         voteFor = (predictedWL === 'W') ? predHt1 : (predHt1 === 'P' ? 'B' : 'P');
                    }
                    if (voteFor === 'P' || voteFor === 'B') {
                        finalVotesPB[voteFor]++;
                    }
                }
            }
        });
        
        let finalChotPB = null;
        if ((finalVotesPB.P + finalVotesPB.B) > 0) {
            if (finalVotesPB.P > finalVotesPB.B) finalChotPB = 'P';
            else if (finalVotesPB.B > finalVotesPB.P) finalChotPB = 'B';
        }
        chotLog = { prediction: finalChotPB, source: 'CHOT_VOTE' };
    }

    // --- APPLY UPDATES TO SESSION DATA ---
    
    // 1. Log HT1 Prediction
    if (predHt1) {
        session.predictions.push({ predicted: predHt1, actual: result, confidence: confHt1 });
    }
    
    // 2. Log Verdict
    if (finalVerdictInfo && predHt1) {
        let finalPred = predHt1;
        if (finalVerdictInfo.verdict === 'against') finalPred = predHt1 === 'P' ? 'B' : 'P';
        session.verdictPredictions.push({
            verdict: finalVerdictInfo.verdict,
            predicted: finalPred,
            actual: result
        });
    }

    // 3. Log Chot
    if (chotLog && chotLog.prediction) {
        session.chotPredictions.push({
            predicted: chotLog.prediction,
            actual: result,
            source: chotLog.source
        });
    }

    // 4. Update Performance (Chot & HT1)
    updateChotLengthPerformance(session, predHt1, result);
    
    // 5. Update History
    session.history.push(result);
    
    // 6. Update Optimal Length (HT1) for next turn
    session.optimalLength = updateLengthPerformanceAndFindOptimal([...session.history].slice(0, -1), Object.values(state.sessions), result);
}

// Wrapper for UI Interaction
function handleAddResultClick(result) {
    if (!state.currentSessionId) return;
    const session = state.sessions[state.currentSessionId];
    
    // Calculate and Push Logic (reusing the function used for import)
    // Note: For live click, we could arguably use the state computed by UI, 
    // but re-calculating ensures consistency with Import logic.
    // However, to keep "Live" feel, we trust the UI state if available.
    
    // Simplified logic for Live Click to reuse existing state (faster response)
    const chotRec = state.currentChotPredictionForLog;
    const tier1Prediction = state.originalSystemPrediction;
    
    if (state.currentPrediction) {
        session.predictions.push({ predicted: state.currentPrediction.prediction, actual: result, confidence: state.currentPrediction.confidence });
    }
    if (state.currentFinalPrediction) {
        session.verdictPredictions.push({
            verdict: state.currentFinalPrediction.verdict,
            predicted: state.currentFinalPrediction.prediction,
            actual: result
        });
    }
    if (chotRec && chotRec.prediction) {
        session.chotPredictions.push({ predicted: chotRec.prediction, actual: result, source: 'CHOT_VOTE' });
    }
    
    updateChotLengthPerformance(session, tier1Prediction, result);
    session.history.push(result);
    session.optimalLength = updateLengthPerformanceAndFindOptimal([...session.history].slice(0, -1), Object.values(state.sessions), result);

    // Reset State
    state.currentPrediction = null;
    state.originalSystemPrediction = null;
    state.currentFinalPrediction = null;
    state.currentChotPredictionForLog = null;
    
    saveSessions();
    updateAllUI();
}

// --- FIX 1: OPTIMIZED IMPORT LOGIC ---
function runSimulation(importedSessions) {
    state.sessions = {};
    state.currentSessionId = null;
    localStorage.removeItem('baccaratPatternSessions_v11_sim');
    localStorage.removeItem('lastActiveSession_v11_sim');
    
    const sortedSessionIds = Object.keys(importedSessions).sort((a, b) => {
        const timeA = parseInt(a.split('-')[1] || 0);
        const timeB = parseInt(b.split('-')[1] || 0);
        return timeA - timeB;
    });

    sortedSessionIds.forEach((sessionId) => {
        const importedSession = importedSessions[sessionId];
        if (!importedSession || !importedSession.name || !Array.isArray(importedSession.history)) return;

        const newId = sessionId;
        state.sessions[newId] = {
            name: importedSession.name,
            history: [], predictions: [], verdictPredictions: [], chotPredictions: [],
            lengthPerformance: {}, optimalLength: null,
            chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {}),
            chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {}),
        };

        // Processing Loop - PURE LOGIC, NO UI
        importedSession.history.forEach((result) => {
            state.currentSessionId = newId;
            if (result === 'P' || result === 'B') {
                calculateSessionStateForNewResult(state.sessions[newId], result, true);
            }
        });
    });

    if (Object.keys(state.sessions).length > 0) {
        const lastId = Object.keys(state.sessions).pop();
        loadSession(lastId);
    } else {
        createNewSession();
    }
    updateSessionSelector();
    updateAllUI(); // UPDATE UI ONLY ONCE AT THE END
}

// --- REST OF HELPERS ---
function updateLengthPerformanceAndFindOptimal(history, allSessions, newResult) {
    const session = state.sessions[state.currentSessionId];
    if (!session) return null;
    if (!session.lengthPerformance) session.lengthPerformance = {};
    const candidates = [];
    for (let len = 10; len <= 20; len++) {
        if (history.length < len) continue;
        const pattern = history.slice(-len);
        const { prediction } = state.matcher.getPredictionForPattern(pattern, allSessions);
        if (prediction) {
            if (!session.lengthPerformance[len]) session.lengthPerformance[len] = { wins: 0, total: 0 };
            const stats = session.lengthPerformance[len];
            // Only update stats if we have a new result (newResult is not null)
            if (newResult) {
                stats.total++;
                if (prediction === newResult) stats.wins++;
            }
            if (stats.total > 0) {
                candidates.push({ length: len, rate: stats.wins / stats.total, total: stats.total });
            }
        }
    }
    if (candidates.length === 0) return session.optimalLength;
    candidates.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
    return candidates[0].length;
}

function updateChotLengthPerformance(session, tier1Prediction, actualResult) {
    if (!session || !tier1Prediction) return;
    const actualWL = (tier1Prediction === actualResult) ? 'W' : 'L';
    const allSequences = getChotAnalysisData();
    if (!session.chotLengthPerformance) session.chotLengthPerformance = CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {});
    if (!session.chotOptimalLengths) session.chotOptimalLengths = CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {});

    const newChotOptimalLengths = { ...session.chotOptimalLengths };
    for (const sourceKey of CHOT_SOURCES) {
        const perfData = session.chotLengthPerformance[sourceKey];
        const historicalSequences = { ...allSequences[sourceKey] };
        if(historicalSequences) delete historicalSequences[state.currentSessionId];
        const fullCurrentSequence = allSequences[sourceKey]?.[state.currentSessionId] || "";
        const prevSequence = fullCurrentSequence.slice(0, -1);
        const candidates = [];
        for (let len = 3; len <= 20; len++) {
            if (prevSequence.length < len) continue;
            const pattern = prevSequence.slice(-len);
            const stats = findNextOutcomeInHistory(pattern, historicalSequences);
            if (stats.total > 0 && stats.W !== stats.L) {
                const predictedWL = (stats.W > stats.L) ? 'W' : 'L';
                if (!perfData[len]) perfData[len] = { wins: 0, total: 0 };
                perfData[len].total++;
                if (predictedWL === actualWL) perfData[len].wins++;
            }
            if (perfData[len] && perfData[len].total > 0) {
                candidates.push({ length: len, rate: perfData[len].wins / perfData[len].total, total: perfData[len].total });
            }
        }
        if (candidates.length > 0) {
            candidates.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
            newChotOptimalLengths[sourceKey] = candidates[0].length;
        } else {
            newChotOptimalLengths[sourceKey] = null;
        }
    }
    session.chotOptimalLengths = newChotOptimalLengths;
}

// --- FIX 2: UNDO LOGIC ---
function undoLast() {
    if (!state.currentSessionId) return;
    const session = state.sessions[state.currentSessionId];
    if(session.history.length === 0) return;

    const lastResult = session.history.pop();
    
    // Capture info needed to undo performance stats
    const tier1PredictionToUndoObj = session.predictions.length > 0 ? session.predictions[session.predictions.length - 1] : null;
    const tier1PredictionToUndo = tier1PredictionToUndoObj ? tier1PredictionToUndoObj.predicted : null;

    // --- CRITICAL FIX: POP DATA BEFORE RECALCULATING STATS ---
    if (session.chotPredictions.length > 0) session.chotPredictions.pop();
    if (session.predictions.length > 0) session.predictions.pop();
    if (session.verdictPredictions.length > 0) session.verdictPredictions.pop();

    // Undo Chot Performance
    if (tier1PredictionToUndo) {
        const actualWLHt1 = (tier1PredictionToUndo === lastResult) ? 'W' : 'L';
        const allSequencesChot = getChotAnalysisData(); // Now clean
        const newChotOptimalLengths = { ...session.chotOptimalLengths };
        for (const sourceKey of CHOT_SOURCES) {
             const perfDataChot = session.chotLengthPerformance[sourceKey];
             const historicalSequencesChot = { ...allSequencesChot[sourceKey] };
             if (historicalSequencesChot) delete historicalSequencesChot[state.currentSessionId];
             const prevSequenceChot = allSequencesChot[sourceKey]?.[state.currentSessionId] || "";
             const candidatesChot = [];
             for (let len = 3; len <= 20; len++) {
                 if (prevSequenceChot.length < len) continue;
                 const pattern = prevSequenceChot.slice(-len);
                 const stats = findNextOutcomeInHistory(pattern, historicalSequencesChot);
                 if (stats.total > 0 && stats.W !== stats.L) {
                     const predictedWL = (stats.W > stats.L) ? 'W' : 'L';
                     if (perfDataChot[len] && perfDataChot[len].total > 0) {
                         perfDataChot[len].total--;
                         if (predictedWL === actualWLHt1 && perfDataChot[len].wins > 0) perfDataChot[len].wins--;
                     }
                 }
                 if (perfDataChot[len] && perfDataChot[len].total > 0) {
                     candidatesChot.push({ length: len, rate: perfDataChot[len].wins / perfDataChot[len].total, total: perfDataChot[len].total });
                 }
             }
             if (candidatesChot.length > 0) {
                 candidatesChot.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
                 newChotOptimalLengths[sourceKey] = candidatesChot[0].length;
             } else {
                 newChotOptimalLengths[sourceKey] = null;
             }
        }
        session.chotOptimalLengths = newChotOptimalLengths;
    }

    // Undo HT1 Performance
    if (session.lengthPerformance) {
        const historyForUndo = session.history; // Already popped
        for (let len = 10; len <= 20; len++) {
             if (historyForUndo.length < len) continue;
             const pattern = historyForUndo.slice(-len);
             // Use temp session for prediction to avoid side effects
             const tempAllSessions = Object.values(state.sessions).map(s => 
                 s.sessionId === state.currentSessionId ? { ...s, history: [...historyForUndo] } : s
             );
             const { prediction } = state.matcher.getPredictionForPattern(pattern, tempAllSessions);
             if (prediction) {
                 const stats = session.lengthPerformance[len];
                 if (stats && stats.total > 0) {
                     stats.total--;
                     if (prediction === lastResult && stats.wins > 0) stats.wins--;
                 }
             }
        }
    }
    // Recalc HT1 Optimal
    session.optimalLength = updateLengthPerformanceAndFindOptimal(session.history, Object.values(state.sessions), null);
    
    saveSessions();
    updateAllUI();
}

function clearCurrentSessionHistory() {
    if (!state.currentSessionId) return;
    const session = state.sessions[state.currentSessionId];
    session.history = [];
    session.predictions = [];
    session.verdictPredictions = [];
    session.chotPredictions = [];
    session.lengthPerformance = {};
    session.optimalLength = null;
    session.chotLengthPerformance = CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {});
    session.chotOptimalLengths = CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {});
    saveSessions();
    updateAllUI();
}

// --- UI UPDATERS ---
function updateBigRoadUI() {
    const history = state.sessions[state.currentSessionId]?.history || [];
    const roadDiv = document.getElementById('bigRoadDisplay');
    document.getElementById('totalGames').textContent = history.length;
    if (history.length === 0) {
        roadDiv.innerHTML = '<p class="text-gray-500 p-4">Ch∆∞a c√≥ k·∫øt qu·∫£...</p>';
        roadDiv.style.display = 'block';
        return;
    }
    roadDiv.style.display = 'grid';
    roadDiv.innerHTML = '';
    const columns = [];
    let currentCol = [history[0]];
    for (let i = 1; i < history.length; i++) {
        if (history[i] === history[i-1]) currentCol.push(history[i]);
        else { columns.push(currentCol); currentCol = [history[i]]; }
    }
    columns.push(currentCol);
    columns.forEach(colData => {
        const colDiv = document.createElement('div');
        colDiv.className = 'road-col';
        colData.forEach(item => {
            const itemDiv = document.createElement('div');
            itemDiv.className = `road-item ${item === 'P' ? 'bg-blue-600' : 'bg-red-600'}`;
            itemDiv.textContent = item;
            colDiv.appendChild(itemDiv);
        });
        roadDiv.appendChild(colDiv);
    });
    roadDiv.scrollLeft = roadDiv.scrollWidth;
}

function updateAnalysisUI() {
    const session = state.sessions[state.currentSessionId] || { history: [], optimalLength: null, lengthPerformance: {} };
    const { prediction, recommendation, analysisText, confidence, isCertain } = state.matcher.getPrediction(session.history, Object.values(state.sessions), {
        optimalLength: session.optimalLength,
        lengthPerformance: session.lengthPerformance
    });
    
    state.currentPrediction = { prediction, confidence };
    state.originalSystemPrediction = prediction;
    
    state.confidenceSequenceData = getConfidenceSequenceData();
    const verdictContext = {
        prediction, confidence,
        sequenceData: state.confidenceSequenceData,
        currentSessionId: state.currentSessionId
    };
    const finalVerdict = getFinalVerdict(verdictContext);
    let finalPredictionForDisplay = prediction;
    if (finalVerdict.verdict === 'against' && !isCertain) {
        finalPredictionForDisplay = prediction === 'P' ? 'B' : 'P';
    }
    state.currentFinalPrediction = { verdict: finalVerdict.verdict, prediction: finalPredictionForDisplay };
    
    // UI Rendering
    const analysisResultDiv = document.getElementById('analysisResult'), analysisCard = document.getElementById('analysis-card');
    analysisCard.classList.remove('card-glow-p', 'card-glow-b', 'card-glow-certain');
    
    let verdictHTML = `<div class="mt-3 p-3 text-center bg-gray-800 rounded-lg text-sm font-semibold ${
        finalVerdict.verdict === 'follow' || isCertain ? 'text-green-300' :
        finalVerdict.verdict === 'against' ? 'text-red-300' : 'text-yellow-300'
    }"><strong>Ph√°n Quy·∫øt H·ªá Th·ªëng:</strong> ${isCertain ? 'Tay ch·∫Øc ch·∫Øn' : finalVerdict.explanation}</div>`;

    if (prediction) {
        let recText = recommendation;
        if(finalVerdict.verdict === 'against' && !isCertain) recText = 'ƒêI NG∆Ø·ª¢C H·ªÜ TH·ªêNG';
        
        let html = `
        <div class="text-center bg-gray-900 py-6 rounded-lg border-2 ${finalPredictionForDisplay === 'P' ? 'border-blue-500' : 'border-red-500'}">
            <p class="text-lg text-gray-400 mb-2">ƒê·ªÅ xu·∫•t theo h·ªá th·ªëng:</p>
            <p class="text-3xl font-extrabold ${finalPredictionForDisplay === 'P' ? 'text-blue-400' : 'text-red-400'}">${recText}</p>
            <p class="text-4xl font-bold mt-2">${finalPredictionForDisplay === 'P' ? 'üë§ PLAYER' : 'üè¶ BANKER'}</p>
            ${verdictHTML}
        </div>
        <div class="bg-gray-700 p-4 rounded-lg mt-4">
            <p class="font-semibold text-gray-300">Ph√¢n t√≠ch:</p>
            <p class="text-gray-400 whitespace-pre-wrap text-sm">${analysisText}</p>
        </div>`;
        
        if (isCertain) analysisCard.classList.add('card-glow-certain');
        else analysisCard.classList.add(finalPredictionForDisplay === 'P' ? 'card-glow-p' : 'card-glow-b');
        analysisResultDiv.innerHTML = html;
    } else {
        analysisResultDiv.innerHTML = `<p class="text-gray-400 text-center py-8 whitespace-pre-wrap">${analysisText}</p>`;
    }
    updateStatsUI(); // Helpers for stats
}

function updateChotAnalysisUI() {
    const finalChotResultDiv = document.getElementById('finalChotResult');
    const finalChotResultText = document.getElementById('finalChotResultText');
    const chotAnalysisDetailsDiv = document.getElementById('chotAnalysisDetails');
    const chotHistoryChartDiv = document.getElementById('chotHistoryChart');
    const chotAccuracyStatsSpan = document.getElementById('chotAccuracyStats');

    if (!finalChotResultDiv) return;

    const originalSystemPB = state.originalSystemPrediction;
    const currentConfidence = state.currentPrediction?.confidence;
    const finalVerdictInfo = state.currentFinalPrediction;
    
    const activeSourcesKeys = new Set();
    if (originalSystemPB && finalVerdictInfo) {
        if (finalVerdictInfo.verdict === 'follow') activeSourcesKeys.add('follow');
        else if (finalVerdictInfo.verdict === 'against') activeSourcesKeys.add('against');
        const activeConfidenceRange = CONFIDENCE_RANGES.find(r => currentConfidence >= r.min && currentConfidence < r.max);
        if (activeConfidenceRange) activeSourcesKeys.add(activeConfidenceRange.key);
    }

    const allSequences = getChotAnalysisData();
    const finalVotesPB = { P: 0, B: 0 };
    let analysisRowsHTML = '';
    
    // --- CHOT ANALYSIS LOOP ---
    if (state.currentSessionId && originalSystemPB) {
        const sources = CHOT_SOURCES.map(key => ({
            key: key,
            name: key === 'follow' ? 'Theo HT' : key === 'against' ? 'Ng∆∞·ª£c HT' : `${key.replace('-', ' - ')}%`
        }));
        
        for (const source of sources) {
            const isActive = activeSourcesKeys.has(source.key);
            const currentSequence = allSequences[source.key]?.[state.currentSessionId] || "";
            const historicalData = { ...allSequences[source.key] };
            if(historicalData) delete historicalData[state.currentSessionId];
            
            const analysisResult = getChotPrediction(currentSequence, historicalData, source.key);
            const predictedWL = analysisResult.predictedWL || null;
            let finalPBprediction = null;
            let voteFor = null;

            if (isActive && predictedWL) {
                if (source.key === 'against') {
                    voteFor = (predictedWL === 'W') ? (originalSystemPB === 'P' ? 'B' : 'P') : originalSystemPB;
                } else {
                    voteFor = (predictedWL === 'W') ? originalSystemPB : (originalSystemPB === 'P' ? 'B' : 'P');
                }
                
                // --- FIX 3: Safety Check ---
                if (voteFor === 'P' || voteFor === 'B') {
                    finalVotesPB[voteFor]++;
                    finalPBprediction = voteFor;
                }
            }
            analysisRowsHTML += getChotRowHTML(source.name, currentSequence, analysisResult, isActive, finalPBprediction);
        }
    }

    // --- RENDER VOTES ---
    let finalChotText = '... Ch·ªù t√≠n hi·ªáu ...';
    let finalChotColor = 'text-gray-400';
    let finalChotBorder = 'border-purple-500';
    let finalChotPB = null;
    const totalVotes = finalVotesPB.P + finalVotesPB.B;

    if (totalVotes > 0) {
        if (finalVotesPB.P > finalVotesPB.B) {
            finalChotPB = 'P'; finalChotText = `PLAYER (${finalVotesPB.P}/${totalVotes} phi·∫øu)`; finalChotColor = 'text-blue-400'; finalChotBorder = 'border-blue-500';
        } else if (finalVotesPB.B > finalVotesPB.P) {
            finalChotPB = 'B'; finalChotText = `BANKER (${finalVotesPB.B}/${totalVotes} phi·∫øu)`; finalChotColor = 'text-red-400'; finalChotBorder = 'border-red-500';
        } else {
            finalChotText = `H√íA PHI·∫æU (${finalVotesPB.P} - ${finalVotesPB.B})`; finalChotColor = 'text-yellow-400'; finalChotBorder = 'border-yellow-500';
        }
    } else if (originalSystemPB) {
        finalChotText = 'Kh√¥ng ƒë·ªß t√≠n hi·ªáu';
    }

    state.currentChotPredictionForLog = { prediction: finalChotPB, source: 'CHOT_VOTE' };
    
    finalChotResultDiv.className = `text-center bg-gray-900 py-4 rounded-lg border-2 ${finalChotBorder} mb-4 transition-all duration-300`;
    finalChotResultText.className = `text-2xl font-extrabold ${finalChotColor}`;
    finalChotResultText.textContent = finalChotText;
    chotAnalysisDetailsDiv.innerHTML = analysisRowsHTML || '<p class="text-gray-500 text-center py-4">Ch·ªù d·ªØ li·ªáu...</p>';

    // --- RENDER HISTORY ---
    const session = state.sessions[state.currentSessionId];
    const chotHistory = session?.chotPredictions || [];
    let correctChot = 0;
    let barsHTML = '';
    const historyToShow = chotHistory.slice(-50);
    historyToShow.forEach(p => {
        const isCorrect = p.predicted === p.actual;
        if(isCorrect) correctChot++;
        barsHTML += `<div class="history-bar ${isCorrect ? 'history-bar-correct' : 'history-bar-incorrect'}" title="${p.predicted} vs ${p.actual}"></div>`;
    });
    chotHistoryChartDiv.innerHTML = barsHTML || '<p class="text-gray-600 text-xs text-center w-full">Ch∆∞a c√≥ d·ªØ li·ªáu...</p>';
    const rate = chotHistory.length > 0 ? (correctChot / chotHistory.length * 100).toFixed(1) : '0.0';
    chotAccuracyStatsSpan.textContent = `ƒê√∫ng: ${correctChot}/${chotHistory.length} (${rate}%)`;
}

function getChotRowHTML(name, currentSequence, analysisResult, isActive, finalPBprediction) {
    // Simplified for brevity, identical logic to original but cleaner
    let wlText = '-', wlColor = 'text-gray-500', typeDisplay = '-';
    if(analysisResult.predictedWL) {
        const { stats } = analysisResult;
        const rate = stats.total > 0 ? (analysisResult.predictedWL === 'W' ? stats.W : stats.L) / stats.total * 100 : 0;
        wlText = `-> ${analysisResult.predictedWL} (${rate.toFixed(0)}%)`;
        wlColor = analysisResult.predictedWL === 'W' ? 'text-green-400' : 'text-red-400';
    }
    typeDisplay = analysisResult.predictionType === 'OPTIMAL' ? `Opt ${analysisResult.optimalLength}` : 
                  analysisResult.predictionType === 'MAX_STREAK' ? analysisResult.explanation : 
                  analysisResult.predictionType === 'FALLBACK' ? `FB ${analysisResult.optimalLength}` : typeDisplay;
    
    const pbHtml = isActive && finalPBprediction ? `<span class="font-bold ${finalPBprediction === 'P' ? 'text-blue-400' : 'text-red-400'} ml-1">[${finalPBprediction}]</span>` : '';
    const activeClass = isActive ? 'bg-gray-700 bg-opacity-60 ring-1 ring-purple-500' : 'bg-gray-900';
    
    // Mini bar chart
    const hist = currentSequence.slice(-20).split('').map(r => 
        `<div class="flex-shrink-0 w-1 ${r === 'W' ? 'bg-green-500 h-4' : 'bg-red-500 h-1.5'} rounded-t-sm"></div>`
    ).join('');

    return `<div class="grid grid-cols-12 gap-2 items-center text-xs mb-1 p-1.5 ${activeClass} rounded-lg">
        <div class="col-span-2 font-semibold ${isActive ? 'text-purple-300' : 'text-gray-300'} truncate">${name}</div>
        <div class="col-span-3 text-center text-gray-400 truncate">${typeDisplay}</div>
        <div class="col-span-3 flex items-end h-4 gap-px overflow-hidden">${hist}</div>
        <div class="col-span-4 text-right font-bold ${wlColor}">${wlText}${pbHtml}</div>
    </div>`;
}

function updateStatsUI() {
    // Accuracy
    const predictions = state.sessions[state.currentSessionId]?.predictions || [];
    const stats = getPredictionStats(predictions);
    document.getElementById('accuracyRate').textContent = `${stats.rate.toFixed(1)}%`;
    document.getElementById('correctPredictions').textContent = stats.correct;
    document.getElementById('totalPredictions').textContent = stats.total;
    
    // Global Accuracy
    const allPredictions = Object.values(state.sessions).flatMap(s => s.predictions || []);
    const gStats = getPredictionStats(allPredictions);
    document.getElementById('globalAccuracyRate').textContent = `${gStats.rate.toFixed(1)}%`;
    document.getElementById('globalCorrectPredictions').textContent = gStats.correct;
    document.getElementById('globalTotalPredictions').textContent = gStats.total;

    updateConfidenceStatsUI();
    updateVerdictStatsUI();
}

function updateConfidenceStatsUI() {
    const predictions = state.sessions[state.currentSessionId]?.predictions || [];
    const ranges = calculateConfidenceRangeStats(predictions);
    const tableDiv = document.getElementById('confidenceStatsTable');
    
    if(predictions.length === 0) {
        tableDiv.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ d·ªØ li·ªáu.</p>';
        document.getElementById('confidenceRecommendation').innerHTML = '';
        return;
    }

    let html = `<div class="grid gap-x-2 text-xs font-semibold text-gray-400 px-3" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;"><span>Kho·∫£ng</span><span class="text-center">Di·ªÖn Bi·∫øn</span><span class="text-center">T·ªïng</span><span class="text-center">Th·∫Øng</span><span class="text-right">T·ª∑ L·ªá</span></div>`;
    let bestRange = null, worstRange = null;
    let maxRate = -1, minRate = 101;

    ranges.forEach(range => {
        if(range.total >= 3) {
            if(range.rate > maxRate) { maxRate = range.rate; bestRange = range; }
            if(range.rate < minRate) { minRate = range.rate; worstRange = range; }
        }
        
        const preds = predictions.filter(p => p.confidence >= range.min && p.confidence < range.max);
        const bars = preds.slice(-20).map(p => 
            `<div class="flex-shrink-0 w-1 ${p.predicted === p.actual ? 'bg-green-500 h-4' : 'bg-red-500 h-1.5'} rounded-t-sm"></div>`
        ).join('');
        
        const rateColor = range.rate >= 60 ? 'text-green-400' : (range.rate >= 50 ? 'text-yellow-400' : 'text-red-400');
        const highlight = range === bestRange ? 'bg-green-900 bg-opacity-20 border border-green-700' : (range === worstRange ? 'bg-red-900 bg-opacity-20 border border-red-700' : 'bg-gray-700 bg-opacity-30');

        html += `<div class="grid gap-x-2 items-center ${highlight} p-2 rounded-lg mt-1 text-xs" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;">
            <span class="font-medium text-gray-300">${range.min}-${range.max > 100 ? 100 : range.max}%</span>
            <div class="flex items-end h-4 gap-px overflow-hidden">${bars}</div>
            <span class="text-white text-center">${range.total}</span>
            <span class="text-green-400 text-center">${range.wins}</span>
            <span class="font-bold text-right ${rateColor}">${range.rate > -1 ? range.rate.toFixed(1) + '%' : '-'}</span>
        </div>`;
    });
    
    tableDiv.innerHTML = html;
    
    let recHtml = '';
    if(bestRange) recHtml += `<p class="text-sm text-yellow-300">‚ú® Kho·∫£ng V√†ng: <b class="text-green-400">${maxRate.toFixed(1)}%</b> (${bestRange.min}-${bestRange.max > 100 ? 100 : bestRange.max}%)</p>`;
    if(worstRange) recHtml += `<p class="text-sm text-red-300 mt-1">üíÄ T·ª≠ Th·∫ßn: <b class="text-red-400">${minRate.toFixed(1)}%</b> (${worstRange.min}-${worstRange.max > 100 ? 100 : worstRange.max}%)</p>`;
    document.getElementById('confidenceRecommendation').innerHTML = recHtml || '<p class="text-gray-500 text-sm">Ch∆∞a ƒë·ªß d·ªØ li·ªáu (c·∫ßn 3+ v√°n).</p>';
}

function updateVerdictStatsUI() {
    const tableDiv = document.getElementById('verdictStatsTable');
    const predictions = state.sessions[state.currentSessionId]?.verdictPredictions || [];
    if(predictions.length === 0) {
        tableDiv.innerHTML = '<p class="text-gray-500 text-center py-4">Ch∆∞a c√≥ d·ªØ li·ªáu.</p>';
        return;
    }
    const stats = { follow: {t:0, w:0, p:[]}, against: {t:0, w:0, p:[]} };
    predictions.forEach(p => {
        if(p.verdict === 'follow') { stats.follow.t++; stats.follow.p.push(p); if(p.predicted===p.actual) stats.follow.w++; }
        if(p.verdict === 'against') { stats.against.t++; stats.against.p.push(p); if(p.predicted===p.actual) stats.against.w++; }
    });
    
    const genRow = (label, d) => {
        const rate = d.t > 0 ? (d.w/d.t*100) : 0;
        const bars = d.p.slice(-20).map(p => `<div class="flex-shrink-0 w-1 ${p.predicted === p.actual ? 'bg-green-500 h-4' : 'bg-red-500 h-1.5'} rounded-t-sm"></div>`).join('');
        return `<div class="grid gap-x-2 items-center bg-gray-700 bg-opacity-30 p-2 rounded-lg mt-1 text-xs" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;">
            <span class="font-medium text-gray-300">${label}</span>
            <div class="flex items-end h-4 gap-px overflow-hidden">${bars}</div>
            <span class="text-white text-center">${d.t}</span>
            <span class="text-green-400 text-center">${d.w}</span>
            <span class="font-bold text-right ${rate >= 50 ? 'text-green-400' : 'text-red-400'}">${d.t > 0 ? rate.toFixed(1)+'%' : '-'}</span>
        </div>`;
    };
    tableDiv.innerHTML = `<div class="grid gap-x-2 text-xs font-semibold text-gray-400 px-3" style="grid-template-columns: 2fr 4fr 2fr 2fr 3fr;"><span>Lo·∫°i</span><span class="text-center">Di·ªÖn Bi·∫øn</span><span class="text-center">T</span><span class="text-center">W</span><span class="text-right">%</span></div>` + genRow('Theo HT', stats.follow) + genRow('Ng∆∞·ª£c HT', stats.against);
}

function updateAllUI() {
    updateBigRoadUI();
    updateAnalysisUI();
    updateChotAnalysisUI();
}

// --- BASIC APP UTILS ---
function getSessions() { return JSON.parse(localStorage.getItem('baccaratPatternSessions_v11_sim')) || {}; }
function saveSessions() { localStorage.setItem('baccaratPatternSessions_v11_sim', JSON.stringify(state.sessions)); localStorage.setItem('lastActiveSession_v11_sim', state.currentSessionId); }
function createNewSession() {
    const newId = `session-${Date.now()}`;
    state.currentSessionId = newId;
    state.sessions[newId] = {
        name: `Phi√™n ${new Date().toLocaleString('vi-VN')}`,
        history: [], predictions: [], verdictPredictions: [], chotPredictions: [],
        lengthPerformance: {}, optimalLength: null,
        chotLengthPerformance: CHOT_SOURCES.reduce((acc, k) => { acc[k] = {}; return acc; }, {}),
        chotOptimalLengths: CHOT_SOURCES.reduce((acc, k) => { acc[k] = null; return acc; }, {})
    };
    saveSessions();
    updateSessionSelector();
    updateAllUI();
}
function loadSession(id) {
    if (state.sessions[id]) {
        state.currentSessionId = id;
        state.currentPrediction = null; state.originalSystemPrediction = null; state.currentFinalPrediction = null; state.currentChotPredictionForLog = null;
        updateSessionSelector();
        updateAllUI();
    }
}
function updateSessionSelector() {
    const s = document.getElementById('sessionSelector');
    s.innerHTML = '';
    Object.keys(state.sessions).sort((a,b) => parseInt(b.split('-')[1])-parseInt(a.split('-')[1])).forEach(k => {
        const opt = document.createElement('option');
        opt.value = k;
        opt.textContent = `${state.sessions[k].name} (${state.sessions[k].history.length} v√°n)`;
        if(k===state.currentSessionId) opt.selected = true;
        s.appendChild(opt);
    });
    s.onclick = () => { if(s.selectedOptions.length===1 && s.value!==state.currentSessionId) loadSession(s.value); };
}
function deleteSelectedSessions() {
    const ids = Array.from(document.getElementById('sessionSelector').selectedOptions).map(o=>o.value);
    if(ids.length === 0) return showToast('Ch∆∞a ch·ªçn phi√™n.', 'warning');
    showCustomConfirm(`X√≥a ${ids.length} phi√™n?`, () => {
        ids.forEach(id => delete state.sessions[id]);
        if(ids.includes(state.currentSessionId)) state.currentSessionId = null;
        saveSessions();
        initializeApp();
        showToast('ƒê√£ x√≥a.', 'success');
    });
}
function deleteAllSessions() {
    showCustomConfirm('X√ìA T·∫§T C·∫¢ D·ªÆ LI·ªÜU?', () => {
        state.sessions={}; state.currentSessionId=null;
        localStorage.removeItem('baccaratPatternSessions_v11_sim');
        initializeApp();
        showToast('ƒê√£ x√≥a s·∫°ch.', 'success');
    });
}
function renameSession() {
    if(!state.currentSessionId) return;
    showCustomPrompt('T√™n m·ªõi:', state.sessions[state.currentSessionId].name, (n) => {
        if(n) { state.sessions[state.currentSessionId].name = n; saveSessions(); updateSessionSelector(); }
    });
}
function toggleSessionManagement() {
    const c = document.getElementById('sessionManagementContent'), i = document.getElementById('toggleSessionIcon');
    if(c.style.maxHeight && c.style.maxHeight !== '0px') { c.style.maxHeight = '0px'; i.style.transform = 'rotate(-180deg)'; }
    else { c.style.maxHeight = c.scrollHeight + 'px'; i.style.transform = 'rotate(0deg)'; }
}

// --- IMPORT/EXPORT ---
function exportData() {
    if(Object.keys(state.sessions).length===0) return showToast('Tr·ªëng.', 'warning');
    const data = JSON.stringify(Object.keys(state.sessions).reduce((acc, k) => {
        acc[k] = { name: state.sessions[k].name, history: state.sessions[k].history }; return acc;
    }, {}), null, 2);
    downloadFile(data, `BaccaratData_${Date.now()}.json`, 'application/json');
}
function exportVerdictStats() { exportStatsCSV('verdictPredictions', ['V√°n', 'Lo·∫°i', 'ƒê·ªÅ xu·∫•t', 'K·∫øt qu·∫£', 'W/L'], p => [p.verdict, p.predicted, p.actual, p.predicted===p.actual?'W':'L']); }
function exportConfidenceStats() { exportStatsCSV('predictions', ['V√°n', 'Tin c·∫≠y', 'ƒê·ªÅ xu·∫•t', 'K·∫øt qu·∫£', 'W/L'], p => [p.confidence.toFixed(1)+'%', p.predicted, p.actual, p.predicted===p.actual?'W':'L']); }
function exportStatsCSV(prop, headers, rowFn) {
    if(!state.currentSessionId) return;
    const list = state.sessions[state.currentSessionId][prop] || [];
    if(list.length===0) return showToast('Kh√¥ng c√≥ d·ªØ li·ªáu.', 'warning');
    const csv = [headers.join(',')].concat(list.map((p,i) => [i+1, ...rowFn(p)].join(','))).join('\n');
    downloadFile('\uFEFF'+csv, `Stats_${prop}_${Date.now()}.csv`, 'text/csv;charset=utf-8;');
}
function downloadFile(content, name, type) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([content], {type}));
    a.download = name;
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
}
function importData(e) {
    const f = e.target.files[0];
    if(!f) return;
    const r = new FileReader();
    r.onload = (evt) => {
        try {
            const data = JSON.parse(evt.target.result);
            showLoadingModal('ƒêang x·ª≠ l√Ω...');
            setTimeout(() => {
                runSimulation(data);
                hideLoadingModal();
                showToast('Th√†nh c√¥ng!', 'success');
            }, 100);
        } catch(err) { hideLoadingModal(); showToast('L·ªói file JSON.', 'error'); }
        e.target.value = '';
    };
    r.readAsText(f);
}

// --- MODALS ---
function showToast(msg, type='info') {
    const c = document.getElementById('toast-container'), t = document.createElement('div');
    t.className = `toast-notification border-${type==='success'?'green':(type==='error'?'red':'blue')}-500`;
    t.textContent = msg; c.appendChild(t);
    setTimeout(() => { t.style.animation='fadeOut 0.5s ease'; setTimeout(()=>t.remove(),500); }, 3000);
}
function showLoadingModal(msg) {
    document.getElementById('modal-container').innerHTML = `<div id="load-m" class="modal-backdrop"><div class="modal-content text-center"><p class="text-white">${msg}</p><div class="mt-4"><svg class="animate-spin h-8 w-8 text-white mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div></div></div>`;
}
function hideLoadingModal() { document.getElementById('modal-container').innerHTML = ''; }
function showCustomConfirm(msg, cb) {
    document.getElementById('modal-container').innerHTML = `<div id="conf-m" class="modal-backdrop"><div class="modal-content"><p class="text-white mb-6">${msg}</p><div class="flex justify-end gap-4"><button id="cc" class="btn bg-gray-600 px-4 py-2 rounded text-white">H·ªßy</button><button id="co" class="btn bg-red-600 px-4 py-2 rounded text-white">OK</button></div></div></div>`;
    document.getElementById('co').onclick=()=>{cb(); hideLoadingModal();}; document.getElementById('cc').onclick=hideLoadingModal;
}
function showCustomPrompt(msg, val, cb) {
    document.getElementById('modal-container').innerHTML = `<div id="pr-m" class="modal-backdrop"><div class="modal-content"><p class="text-white mb-4">${msg}</p><input id="pi" value="${val}" class="w-full bg-gray-700 text-white p-2 rounded mb-4"><div class="flex justify-end gap-4"><button id="pc" class="btn bg-gray-600 px-4 py-2 rounded text-white">H·ªßy</button><button id="po" class="btn bg-blue-600 px-4 py-2 rounded text-white">OK</button></div></div></div>`;
    const i = document.getElementById('pi'); i.focus(); i.select();
    document.getElementById('po').onclick=()=>{cb(i.value); hideLoadingModal();}; document.getElementById('pc').onclick=hideLoadingModal;
}

// --- INIT ---
function initializeApp() {
    state.sessions = getSessions();
    const keys = Object.keys(state.sessions);
    if(keys.length === 0) createNewSession();
    else {
        const last = localStorage.getItem('lastActiveSession_v11_sim');
        loadSession((last && state.sessions[last]) ? last : keys[keys.length-1]);
    }
    document.getElementById('sessionManagementContent').style.maxHeight = '0px';
    document.getElementById('toggleSessionIcon').style.transform = 'rotate(-180deg)';
}
document.addEventListener('DOMContentLoaded', initializeApp);
</script>
<script>
// =================== IFRAME COMMUNICATION FOR HT2 - COMPLETE & OPTIMIZED ===================
(function() {
    // Notify parent that system is ready
    window.addEventListener('load', function() {
        setTimeout(() => {
            window.parent.postMessage({
                source: 'ht2',
                type: 'ready'
            }, '*');
        }, 1000);
    });

    // Listen for messages from parent
    window.addEventListener('message', function(event) {
        if (event.data.source === 'master') {
            handleMasterCommand(event.data);
        }
    });

    function handleMasterCommand(data) {
        switch(data.command) {
            case 'get_accuracy':
                sendAccuracyUpdate();
                break;
                
            case 'get_chot_history':
                sendChotHistory();
                break;
                
            case 'get_session_info':
                sendSessionInfo();
                break;
                
            case 'get_prediction':
                sendPrediction();
                break;
                
            case 'get_system_details':
                sendSystemDetails();
                break;
                
            case 'create_session':
                createSession(data.data);
                break;
                
            case 'rename_session':
                renameSession(data.data);
                break;
                
            case 'load_session':
                loadSession(data.data);
                break;
                
            case 'add_result':
                addResult(data.data);
                break;
                
            case 'undo_last':
                undoLast();
                break;
                
            case 'clear_history':
                clearCurrentSessionHistory();
                break;
                
            case 'import_data':
                importSimulatedData(data.data);
                break;
                
            case 'export_data':
                exportSessionData();
                break;
                
            case 'reset_system':
                resetSystem();
                break;
                
            default:
                console.log('[HT2] Unknown command:', data.command);
        }
    }

    // =================== COMMUNICATION FUNCTIONS ===================

    function sendAccuracyUpdate() {
        try {
            const session = state.sessions[state.currentSessionId];
            if (session && session.chotPredictions) {
                const total = session.chotPredictions.length;
                const correct = session.chotPredictions.filter(p => p.predicted === p.actual).length;
                const accuracy = total > 0 ? (correct / total) * 100 : 0;
                
                window.parent.postMessage({
                    source: 'ht2',
                    type: 'accuracy_update',
                    accuracy: accuracy,
                    correct: correct,
                    total: total
                }, '*');
            } else {
                window.parent.postMessage({
                    source: 'ht2',
                    type: 'accuracy_update',
                    accuracy: 0,
                    correct: 0,
                    total: 0
                }, '*');
            }
        } catch (error) {
            console.error('[HT2] Error sending accuracy update:', error);
        }
    }

    function sendChotHistory() {
        try {
            const session = state.sessions[state.currentSessionId];
            if (session && session.chotPredictions) {
                window.parent.postMessage({
                    source: 'ht2',
                    type: 'chot_history_update',
                    history: session.chotPredictions
                }, '*');
            } else {
                window.parent.postMessage({
                    source: 'ht2',
                    type: 'chot_history_update',
                    history: []
                }, '*');
            }
        } catch (error) {
            console.error('[HT2] Error sending chot history:', error);
        }
    }

    function sendSessionInfo() {
        try {
            const session = state.sessions[state.currentSessionId];
            if (session) {
                window.parent.postMessage({
                    source: 'ht2',
                    type: 'session_update',
                    session: {
                        id: state.currentSessionId,
                        name: session.name,
                        history: session.history || [],
                        current: true
                    }
                }, '*');
            } else {
                window.parent.postMessage({
                    source: 'ht2',
                    type: 'session_update',
                    session: null
                }, '*');
            }
        } catch (error) {
            console.error('[HT2] Error sending session info:', error);
        }
    }

    function sendPrediction() {
        try {
            // Priority: Ch·ªët > Ph√°n Quy·∫øt > H·ªá th·ªëng
            const prediction = state.currentChotPredictionForLog?.prediction || 
                              state.currentFinalPrediction?.prediction || 
                              state.originalSystemPrediction ||
                              state.currentPrediction?.prediction ||
                              null;
            
            window.parent.postMessage({
                source: 'ht2',
                type: 'prediction_update',
                prediction: prediction
            }, '*');
        } catch (error) {
            console.error('[HT2] Error sending prediction:', error);
        }
    }

    function sendSystemDetails() {
        try {
            const details = {
                verdict: null,           // üß† Ph√°n Quy·∫øt
                verdictSimple: null,     // üß† Ph√°n Quy·∫øt ƒë∆°n gi·∫£n (P/B)
                verdictColor: 'text-gray-400',
                chot: null,              // üîê Ch·ªët Ph√°n Quy·∫øt
                chotColor: 'text-gray-400',
                range: null,             // Kho·∫£ng t·ª∑ l·ªá
                rangeAccuracy: null,     // T·ªâ l·ªá ph·∫ßn trƒÉm c·ªßa kho·∫£ng
                rangeTotal: 0,           // T·ªïng s·ªë v√°n trong kho·∫£ng
                rangeWins: 0,            // S·ªë v√°n th·∫Øng trong kho·∫£ng
                intervalHistory: []      // D·ªØ li·ªáu bi·ªÉu ƒë·ªì
            };
            
            // 1. L·∫•y üß† Ph√°n Quy·∫øt (Ph√¢n T√≠ch T·ªïng H·ª£p)
            if (state.currentFinalPrediction && state.currentFinalPrediction.prediction) {
                const verdictType = state.currentFinalPrediction.verdict === 'follow' ? 'THEO' : 
                                  state.currentFinalPrediction.verdict === 'against' ? 'NG∆Ø·ª¢C' : '';
                
                details.verdict = `${state.currentFinalPrediction.prediction} ${verdictType}`.trim();
                details.verdictSimple = state.currentFinalPrediction.prediction;
                details.verdictColor = state.currentFinalPrediction.prediction === 'P' ? 'text-blue-400' : 'text-red-400';
            } else if (state.currentPrediction && state.currentPrediction.prediction) {
                details.verdict = state.currentPrediction.prediction;
                details.verdictSimple = state.currentPrediction.prediction;
                details.verdictColor = state.currentPrediction.prediction === 'P' ? 'text-blue-400' : 'text-red-400';
            } else if (state.originalSystemPrediction) {
                details.verdict = state.originalSystemPrediction;
                details.verdictSimple = state.originalSystemPrediction;
                details.verdictColor = state.originalSystemPrediction === 'P' ? 'text-blue-400' : 'text-red-400';
            }
            
            // 2. L·∫•y üîê Ch·ªët Ph√°n Quy·∫øt
            if (state.currentChotPredictionForLog && state.currentChotPredictionForLog.prediction) {
                details.chot = state.currentChotPredictionForLog.prediction;
                details.chotColor = state.currentChotPredictionForLog.prediction === 'P' ? 'text-blue-400' : 'text-red-400';
            } else {
                // Fallback: Ki·ªÉm tra t·ª´ UI
                const finalChotResultText = document.getElementById('finalChotResultText');
                if (finalChotResultText) {
                    const text = finalChotResultText.textContent || '';
                    if (text.includes('PLAYER')) {
                        details.chot = 'P';
                        details.chotColor = 'text-blue-400';
                    } else if (text.includes('BANKER')) {
                        details.chot = 'B';
                        details.chotColor = 'text-red-400';
                    }
                }
            }
            
            // 3. X√°c ƒë·ªãnh kho·∫£ng t·ª∑ l·ªá v√† t·ªâ l·ªá ph·∫ßn trƒÉm
            const currentConfidence = state.currentPrediction?.confidence;
            const session = state.sessions[state.currentSessionId];
            
            if (currentConfidence !== undefined && session && session.predictions) {
                // T√¨m kho·∫£ng confidence hi·ªán t·∫°i
                const confidenceRanges = [
                    { key: '50-60', min: 50, max: 60 },
                    { key: '60-70', min: 60, max: 70 },
                    { key: '70-80', min: 70, max: 80 },
                    { key: '80-90', min: 80, max: 90 },
                    { key: '90-100', min: 90, max: 100.1 }
                ];
                
                let foundRange = null;
                let rangeDisplay = '';
                
                // T√¨m trong confidenceRanges
                confidenceRanges.forEach(r => {
                    if (currentConfidence >= r.min && currentConfidence < r.max) {
                        foundRange = r;
                        rangeDisplay = `${r.min}-${r.max === 100.1 ? 100 : r.max}%`;
                    }
                });
                
                if (foundRange) {
                    details.range = rangeDisplay;
                    
                    // T√≠nh t·ªâ l·ªá cho kho·∫£ng n√†y
                    const allPredictions = session.predictions || [];
                    const predictionsInRange = allPredictions.filter(p => {
                        const conf = p.confidence || 0;
                        return conf >= foundRange.min && conf < foundRange.max;
                    });
                    
                    details.rangeTotal = predictionsInRange.length;
                    details.rangeWins = predictionsInRange.filter(p => p.predicted === p.actual).length;
                    details.rangeAccuracy = details.rangeTotal > 0 ? 
                        parseFloat((details.rangeWins / details.rangeTotal * 100).toFixed(1)) : 0;
                    
                    // L·∫•y d·ªØ li·ªáu bi·ªÉu ƒë·ªì
                    details.intervalHistory = predictionsInRange.map((pred, index) => ({
                        game: index + 1,
                        predicted: pred.predicted,
                        actual: pred.actual,
                        confidence: pred.confidence,
                        isCorrect: pred.predicted === pred.actual
                    }));
                } else {
                    // N·∫øu kh√¥ng t√¨m th·∫•y, th·ª≠ kho·∫£ng v√†ng/kho·∫£ng t·ª≠
                    const confidenceStats = calculateConfidenceRangeStats(session.predictions || []);
                    const bestRange = confidenceStats.filter(r => r.total >= 3).sort((a, b) => b.rate - a.rate)[0];
                    const worstRange = confidenceStats.filter(r => r.total >= 3).sort((a, b) => a.rate - b.rate)[0];
                    
                    if (bestRange) {
                        const maxDisplay = bestRange.max === 100.1 ? 100 : bestRange.max;
                        details.range = `${bestRange.min}-${maxDisplay}%`;
                        details.rangeAccuracy = bestRange.rate > -1 ? 
                            parseFloat(bestRange.rate.toFixed(1)) : 0;
                        details.rangeTotal = bestRange.total || 0;
                        details.rangeWins = bestRange.wins || 0;
                    }
                }
            }
            
            // G·ª≠i th√¥ng tin chi ti·∫øt h·ªá th·ªëng
            window.parent.postMessage({
                source: 'ht2',
                type: 'system_details_update',
                details: details
            }, '*');
            
        } catch (error) {
            console.error('[HT2] Error sending system details:', error);
            // G·ª≠i th√¥ng tin l·ªói
            window.parent.postMessage({
                source: 'ht2',
                type: 'system_details_update',
                details: {
                    verdict: null,
                    verdictSimple: null,
                    verdictColor: 'text-gray-400',
                    chot: null,
                    chotColor: 'text-gray-400',
                    range: "L·ªói t√≠nh to√°n",
                    rangeAccuracy: 0,
                    intervalHistory: []
                }
            }, '*');
        }
    }

    // =================== SESSION MANAGEMENT FUNCTIONS ===================

    function createSession(sessionData) {
        if (!sessionData || !sessionData.name) {
            showToast('D·ªØ li·ªáu phi√™n kh√¥ng h·ª£p l·ªá', 'error');
            return;
        }
        
        try {
            const newId = sessionData.id || `session-${Date.now()}`;
            state.currentSessionId = newId;
            state.sessions[newId] = {
                name: sessionData.name,
                history: [],
                predictions: [],
                verdictPredictions: [],
                chotPredictions: [],
                lengthPerformance: {},
                optimalLength: null,
                chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { 
                    acc[key] = {}; 
                    return acc; 
                }, {}),
                chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { 
                    acc[key] = null; 
                    return acc; 
                }, {}),
            };
            
            saveSessions();
            updateSessionSelector();
            updateAllUI();
            
            // G·ª≠i th√¥ng tin c·∫≠p nh·∫≠t
            sendSessionInfo();
            sendSystemDetails();
            
            showToast(`ƒê√£ t·∫°o phi√™n: ${sessionData.name}`, 'success');
            
        } catch (error) {
            console.error('[HT2] Error creating session:', error);
            showToast('L·ªói khi t·∫°o phi√™n', 'error');
        }
    }

    function renameSession(sessionData) {
        if (!sessionData || !sessionData.id || !sessionData.name) {
            showToast('D·ªØ li·ªáu ƒë·ªïi t√™n kh√¥ng h·ª£p l·ªá', 'error');
            return;
        }
        
        try {
            if (state.sessions[sessionData.id]) {
                state.sessions[sessionData.id].name = sessionData.name;
                if (state.currentSessionId === sessionData.id) {
                    saveSessions();
                    updateSessionSelector();
                    updateAllUI();
                    
                    sendSessionInfo();
                    sendSystemDetails();
                    
                    showToast(`ƒê√£ ƒë·ªïi t√™n th√†nh: ${sessionData.name}`, 'success');
                }
            } else {
                showToast('Kh√¥ng t√¨m th·∫•y phi√™n', 'error');
            }
        } catch (error) {
            console.error('[HT2] Error renaming session:', error);
            showToast('L·ªói khi ƒë·ªïi t√™n phi√™n', 'error');
        }
    }

    function loadSession(sessionData) {
        if (!sessionData || !sessionData.id) {
            showToast('D·ªØ li·ªáu phi√™n kh√¥ng h·ª£p l·ªá', 'error');
            return;
        }
        
        try {
            // T·∫°o session n·∫øu ch∆∞a t·ªìn t·∫°i
            if (!state.sessions[sessionData.id]) {
                state.sessions[sessionData.id] = {
                    name: sessionData.name || `Phi√™n ${sessionData.id}`,
                    history: sessionData.history || [],
                    predictions: [],
                    verdictPredictions: [],
                    chotPredictions: [],
                    lengthPerformance: {},
                    optimalLength: null,
                    chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { 
                        acc[key] = {}; 
                        return acc; 
                    }, {}),
                    chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { 
                        acc[key] = null; 
                        return acc; 
                    }, {}),
                };
            }
            
            // Load session
            state.currentSessionId = sessionData.id;
            
            // N·∫øu c√≥ history, m√¥ ph·ªèng l·∫°i
            if (sessionData.history && sessionData.history.length > 0) {
                // X√≥a d·ªØ li·ªáu hi·ªán t·∫°i
                const session = state.sessions[sessionData.id];
                session.history = [];
                session.predictions = [];
                session.verdictPredictions = [];
                session.chotPredictions = [];
                
                // M√¥ ph·ªèng t·ª´ng k·∫øt qu·∫£
                sessionData.history.forEach((result, index) => {
                    session.history.push(result);
                    
                    // C·∫≠p nh·∫≠t ph√¢n t√≠ch sau m·ªói k·∫øt qu·∫£
                    if (index >= 9) {
                        updateAnalysisUI();
                        updateChotAnalysisUI();
                    }
                });
                
                // T√≠nh to√°n l·∫°i m·ªçi th·ª©
                updateAllUI();
            }
            
            saveSessions();
            updateSessionSelector();
            updateAllUI();
            
            // G·ª≠i th√¥ng tin c·∫≠p nh·∫≠t
            sendSessionInfo();
            sendSystemDetails();
            
            showToast(`ƒê√£ t·∫£i phi√™n: ${state.sessions[sessionData.id].name}`, 'success');
            
        } catch (error) {
            console.error('[HT2] Error loading session:', error);
            showToast('L·ªói khi t·∫£i phi√™n', 'error');
        }
    }

    // =================== GAME ACTION FUNCTIONS ===================

    function addResult(result) {
        if (!state.currentSessionId) {
            showToast('Ch∆∞a ch·ªçn phi√™n', 'warning');
            return;
        }
        
        if (result !== 'P' && result !== 'B') {
            showToast('K·∫øt qu·∫£ kh√¥ng h·ª£p l·ªá', 'error');
            return;
        }
        
        try {
            const session = state.sessions[state.currentSessionId];
            if (!session) {
                showToast('Phi√™n kh√¥ng t·ªìn t·∫°i', 'error');
                return;
            }
            
            const chotRec = state.currentChotPredictionForLog;
            const tier1Prediction = state.originalSystemPrediction;
            
            // Ghi log Prediction HT2
            if (state.currentPrediction && state.currentPrediction.prediction) {
                session.predictions.push({ 
                    predicted: state.currentPrediction.prediction, 
                    actual: result, 
                    confidence: state.currentPrediction.confidence 
                });
            }
            
            // Ghi log Verdict
            if (!session.verdictPredictions) session.verdictPredictions = [];
            if (state.currentFinalPrediction && state.currentFinalPrediction.prediction) {
                session.verdictPredictions.push({
                    verdict: state.currentFinalPrediction.verdict,
                    predicted: state.currentFinalPrediction.prediction,
                    actual: result
                });
            }
            
            // Ghi log Ch·ªët
            if (!session.chotPredictions) session.chotPredictions = [];
            if (chotRec && chotRec.prediction) {
                session.chotPredictions.push({ 
                    predicted: chotRec.prediction, 
                    actual: result, 
                    source: 'CHOT_VOTE' 
                });
            }
            
            // C·∫≠p nh·∫≠t Performance
            updateChotLengthPerformance(session, tier1Prediction, result);
            
            // Th√™m k·∫øt qu·∫£ v√†o history
            session.history.push(result);
            
            // C·∫≠p nh·∫≠t optimal length
            session.optimalLength = updateLengthPerformanceAndFindOptimal(
                [...session.history].slice(0, -1), 
                Object.values(state.sessions), 
                result
            );
            
            // Reset state cho v√°n sau
            state.currentPrediction = null;
            state.originalSystemPrediction = null;
            state.currentFinalPrediction = null;
            state.currentChotPredictionForLog = null;
            
            saveSessions();
            updateAllUI();
            
            // G·ª≠i t·∫•t c·∫£ c·∫≠p nh·∫≠t
            sendAccuracyUpdate();
            sendChotHistory();
            sendPrediction();
            sendSystemDetails();
            
            showToast(`ƒê√£ th√™m k·∫øt qu·∫£: ${result === 'P' ? 'PLAYER' : 'BANKER'}`, 'success');
            
        } catch (error) {
            console.error('[HT2] Error adding result:', error);
            showToast('L·ªói khi th√™m k·∫øt qu·∫£', 'error');
        }
    }

    function undoLast() {
        if (!state.currentSessionId) {
            showToast('Ch∆∞a ch·ªçn phi√™n', 'warning');
            return;
        }
        
        const session = state.sessions[state.currentSessionId];
        if (session.history.length === 0) {
            showToast('Kh√¥ng c√≥ k·∫øt qu·∫£ ƒë·ªÉ ho√†n t√°c', 'warning');
            return;
        }
        
        try {
            const lastResult = session.history.pop();
            
            // Ho√†n t√°c Ch·ªët
            if (session.chotPredictions && session.chotPredictions.length > 0) {
                session.chotPredictions.pop();
            }

            // Ho√†n t√°c Predictions
            if (session.predictions.length > 0) session.predictions.pop();
            if (session.verdictPredictions && session.verdictPredictions.length > 0) 
                session.verdictPredictions.pop();

            // Recalculate performance
            const tier1PredictionToUndo = session.predictions.length > 0 ? 
                session.predictions[session.predictions.length - 1]?.predicted : null;
            
            if (tier1PredictionToUndo) {
                const actualWLHt1 = (tier1PredictionToUndo === lastResult) ? 'W' : 'L';
                const allSequencesChot = getChotAnalysisData();
                const newChotOptimalLengths = { ...session.chotOptimalLengths };
                
                for (const sourceKey of CHOT_SOURCES) {
                    const perfDataChot = session.chotLengthPerformance[sourceKey];
                    const historicalSequencesChot = { ...allSequencesChot[sourceKey] };
                    if (historicalSequencesChot) delete historicalSequencesChot[state.currentSessionId];
                    const prevSequenceChot = allSequencesChot[sourceKey]?.[state.currentSessionId] || "";
                    const candidatesChot = [];
                    
                    for (let len = 3; len <= 20; len++) {
                        if (prevSequenceChot.length < len) continue;
                        const pattern = prevSequenceChot.slice(-len);
                        const stats = findNextOutcomeInHistory(pattern, historicalSequencesChot);
                        if (stats.total > 0 && stats.W !== stats.L) {
                            const predictedWL = (stats.W > stats.L) ? 'W' : 'L';
                            if (perfDataChot[len] && perfDataChot[len].total > 0) {
                                perfDataChot[len].total--;
                                if (predictedWL === actualWLHt1 && perfDataChot[len].wins > 0) {
                                    perfDataChot[len].wins--;
                                }
                            }
                        }
                        if (perfDataChot[len] && perfDataChot[len].total > 0) {
                            candidatesChot.push({ 
                                length: len, 
                                rate: perfDataChot[len].wins / perfDataChot[len].total, 
                                total: perfDataChot[len].total 
                            });
                        }
                    }
                    
                    if (candidatesChot.length > 0) {
                        candidatesChot.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
                        newChotOptimalLengths[sourceKey] = candidatesChot[0].length;
                    } else {
                        newChotOptimalLengths[sourceKey] = null;
                    }
                }
                session.chotOptimalLengths = newChotOptimalLengths;
            }
            
            // Recalculate HT2 optimal length
            session.optimalLength = updateLengthPerformanceAndFindOptimal(
                session.history, 
                Object.values(state.sessions), 
                null
            );
            
            saveSessions();
            updateAllUI();
            
            // G·ª≠i c·∫≠p nh·∫≠t sau khi ho√†n t√°c
            sendAccuracyUpdate();
            sendChotHistory();
            sendSystemDetails();
            
            showToast('ƒê√£ ho√†n t√°c k·∫øt qu·∫£ cu·ªëi c√πng', 'success');
            
        } catch (error) {
            console.error('[HT2] Error undoing last result:', error);
            showToast('L·ªói khi ho√†n t√°c', 'error');
        }
    }

    function clearCurrentSessionHistory() {
        if (!state.currentSessionId) {
            showToast('Ch∆∞a ch·ªçn phi√™n', 'warning');
            return;
        }
        
        try {
            const session = state.sessions[state.currentSessionId];
            session.history = [];
            session.predictions = [];
            session.verdictPredictions = [];
            session.chotPredictions = [];
            session.lengthPerformance = {};
            session.optimalLength = null;
            session.chotLengthPerformance = CHOT_SOURCES.reduce((acc, key) => { 
                acc[key] = {}; 
                return acc; 
            }, {});
            session.chotOptimalLengths = CHOT_SOURCES.reduce((acc, key) => { 
                acc[key] = null; 
                return acc; 
            }, {});
            
            saveSessions();
            updateAllUI();
            
            // G·ª≠i c·∫≠p nh·∫≠t
            sendAccuracyUpdate();
            sendChotHistory();
            sendSystemDetails();
            
            showToast('ƒê√£ x√≥a l·ªãch s·ª≠ phi√™n', 'success');
            
        } catch (error) {
            console.error('[HT2] Error clearing history:', error);
            showToast('L·ªói khi x√≥a l·ªãch s·ª≠', 'error');
        }
    }

    // =================== IMPORT/EXPORT FUNCTIONS ===================

    function importSimulatedData(data) {
        if (!data || !data.sessions) {
            showToast('D·ªØ li·ªáu import kh√¥ng h·ª£p l·ªá', 'error');
            return;
        }
        
        showLoadingModal('ƒêang nh·∫≠p d·ªØ li·ªáu m√¥ ph·ªèng...');
        
        setTimeout(() => {
            try {
                // N·∫øu l√† master data, c·∫ßn x·ª≠ l√Ω kh√°c
                if (data.isMasterData) {
                    console.log('[HT2] Importing MASTER data');
                    // Chuy·ªÉn ƒë·ªïi sang ƒë·ªãnh d·∫°ng HT2
                    const convertedSessions = {};
                    
                    Object.keys(data.sessions).forEach(sessionId => {
                        const masterSession = data.sessions[sessionId];
                        convertedSessions[sessionId] = {
                            name: masterSession.name,
                            history: masterSession.history || [],
                            predictions: [],
                            verdictPredictions: [],
                            chotPredictions: [],
                            lengthPerformance: {},
                            optimalLength: null,
                            chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { 
                                acc[key] = {}; 
                                return acc; 
                            }, {}),
                            chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { 
                                acc[key] = null; 
                                return acc; 
                            }, {}),
                        };
                    });
                    
                    runSimulation(convertedSessions);
                } else {
                    // D·ªØ li·ªáu HT2 th√¥ng th∆∞·ªùng
                    runSimulation(data.sessions);
                }
                
                hideLoadingModal();
                
                // G·ª≠i t·∫•t c·∫£ c·∫≠p nh·∫≠t
                sendAccuracyUpdate();
                sendChotHistory();
                sendSessionInfo();
                sendSystemDetails();
                
                window.parent.postMessage({
                    source: 'ht2',
                    type: 'import_complete'
                }, '*');
                
                showToast('Import d·ªØ li·ªáu th√†nh c√¥ng', 'success');
                
            } catch (error) {
                hideLoadingModal();
                console.error('[HT2] Import simulation error:', error);
                showToast('L·ªói khi import d·ªØ li·ªáu', 'error');
            }
        }, 100);
    }

    function exportSessionData() {
        try {
            const sessionsToExport = {};
            for (const sessionId in state.sessions) {
                sessionsToExport[sessionId] = {
                    name: state.sessions[sessionId].name,
                    history: state.sessions[sessionId].history,
                    chotPredictions: state.sessions[sessionId].chotPredictions || [],
                    predictions: state.sessions[sessionId].predictions || [],
                    verdictPredictions: state.sessions[sessionId].verdictPredictions || [],
                    chotLengthPerformance: state.sessions[sessionId].chotLengthPerformance || {},
                    chotOptimalLengths: state.sessions[sessionId].chotOptimalLengths || {},
                    lengthPerformance: state.sessions[sessionId].lengthPerformance || {},
                    optimalLength: state.sessions[sessionId].optimalLength
                };
            }
            
            window.parent.postMessage({
                source: 'ht2',
                type: 'export_data',
                sessions: sessionsToExport
            }, '*');
            
            showToast('ƒê√£ chu·∫©n b·ªã d·ªØ li·ªáu export', 'success');
            
        } catch (error) {
            console.error('[HT2] Error exporting session data:', error);
            showToast('L·ªói khi export d·ªØ li·ªáu', 'error');
        }
    }

    // =================== SYSTEM FUNCTIONS ===================

    function resetSystem() {
        try {
            // X√≥a t·∫•t c·∫£ d·ªØ li·ªáu
            state.sessions = {};
            state.currentSessionId = null;
            state.currentPrediction = null;
            state.originalSystemPrediction = null;
            state.currentFinalPrediction = null;
            state.currentChotPredictionForLog = null;
            
            // X√≥a localStorage
            localStorage.removeItem('baccaratPatternSessions_v11_sim');
            localStorage.removeItem('lastActiveSession_v11_sim');
            
            // T·∫°o phi√™n m·ªõi
            createNewSession();
            updateAllUI();
            
            // G·ª≠i c·∫≠p nh·∫≠t
            sendSessionInfo();
            sendSystemDetails();
            
            showToast('ƒê√£ reset h·ªá th·ªëng', 'success');
            
        } catch (error) {
            console.error('[HT2] Error resetting system:', error);
            showToast('L·ªói khi reset h·ªá th·ªëng', 'error');
        }
    }

    // =================== HELPER FUNCTIONS ===================

    function calculateConfidenceRangeStats(predictions) {
        const ranges = [
            { key: '50-60', min: 50, max: 60, total: 0, wins: 0, rate: -1 },
            { key: '60-70', min: 60, max: 70, total: 0, wins: 0, rate: -1 },
            { key: '70-80', min: 70, max: 80, total: 0, wins: 0, rate: -1 },
            { key: '80-90', min: 80, max: 90, total: 0, wins: 0, rate: -1 },
            { key: '90-100', min: 90, max: 100.1, total: 0, wins: 0, rate: -1 }
        ];
        
        ranges.forEach(range => {
            const predictionsForRange = predictions.filter(p => 
                p.confidence >= range.min && p.confidence < range.max
            );
            range.total = predictionsForRange.length;
            range.wins = predictionsForRange.filter(p => p.predicted === p.actual).length;
            range.rate = range.total > 0 ? ((range.wins / range.total) * 100) : -1;
        });
        
        return ranges;
    }

    function findNextOutcomeInHistory(pattern, historicalSequences) {
        if (!pattern || pattern.length < 1) return { W: 0, L: 0, total: 0 };
        let W = 0, L = 0;
        for (const sessionId in historicalSequences) {
            const history = historicalSequences[sessionId];
            if (!history || history.length < pattern.length + 1) continue;
            let i = -1;
            while ((i = history.indexOf(pattern, i + 1)) !== -1) {
                const nextCharIndex = i + pattern.length;
                const prevCharDifferent = (i === 0 || history[i - 1] !== pattern[pattern.length - 1]);
                if (prevCharDifferent && nextCharIndex < history.length) {
                    if (history[nextCharIndex] === 'W') W++; else L++;
                }
            }
        }
        return { W, L, total: W + L };
    }

    function getChotAnalysisData() {
        const sequencesBySource = CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {});
        for (const sessionId in state.sessions) {
            const session = state.sessions[sessionId];
            let followSeq = '', againstSeq = '';
            (session.verdictPredictions || []).forEach(p => {
                const result = p.predicted === p.actual ? 'W' : 'L';
                if (p.verdict === 'follow') followSeq += result;
                else if (p.verdict === 'against') againstSeq += result;
            });
            sequencesBySource.follow[sessionId] = followSeq;
            sequencesBySource.against[sessionId] = againstSeq;
            
            // For confidence ranges
            const ranges = [
                { key: '50-60', min: 50, max: 60 },
                { key: '60-70', min: 60, max: 70 },
                { key: '70-80', min: 70, max: 80 },
                { key: '80-90', min: 80, max: 90 },
                { key: '90-100', min: 90, max: 100.1 }
            ];
            
            ranges.forEach(r => {
                if (!sequencesBySource[r.key]) sequencesBySource[r.key] = {};
                sequencesBySource[r.key][sessionId] = "";
            });
            
            (session.predictions || []).forEach(p => {
                const result = (p.predicted === p.actual) ? 'W' : 'L';
                const foundRange = ranges.find(r => p.confidence >= r.min && p.confidence < r.max);
                if (foundRange) sequencesBySource[foundRange.key][sessionId] += result;
            });
        }
        return sequencesBySource;
    }

    // =================== INITIALIZATION ===================

    // Kh·ªüi t·∫°o s·ª± ki·ªán load
    window.addEventListener('load', function() {
        // G·ª≠i th√¥ng b√°o ready sau khi trang ƒë√£ t·∫£i xong
        setTimeout(() => {
            window.parent.postMessage({
                source: 'ht2',
                type: 'ready'
            }, '*');
            
            // G·ª≠i d·ªØ li·ªáu ban ƒë·∫ßu
            sendSessionInfo();
            sendSystemDetails();
        }, 1500);
    });

})();
</script>
</body>
</html>
